#Include "Totvs.ch"
#INCLUDE 'CMTA261.CH'
#DEFINE USADO CHR(0)+CHR(0)+CHR(1)
#DEFINE LINHAS 999
#Define STR_PULA  chr(13) + chr(10)

Static __lIntWMS

/*??????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?CMAA261  ?Autor ?Marcos Souza      ?Data ?28/01/98  ??
???????????????????????????????????????
??escri?o ?Programa de Transferencias Mod II                           ??
???????????????????????????????????????
??intaxe   ?Void MataZ61(ExpA1,ExpN1)                                   ??
???????????????????????????????????????
??arametros?ExpA1 = Array com dados da rotina automatica                ??
??         ?ExpN1 = Numero da opcao selecionada (rotina automatica)     ??
???????????????????????????????????????
??Uso      ?Generico                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function CMTA261(aAutoItens, nOpcAuto)
	Local aCores		:= A240aCores()
	Local aMemUser
	Local lAcesso		:= .T.
	Local cFiltro		:= ""
	Local lRet 			:= .T.
	Local nRet			:= 0

	Private cCadastro	:= OemToAnsi("Transferência Empenhos") 		//-- Transfer?cia Mod. II
	Private lMAZ61D3	:= (ExistBlock('MAZ61D3'))	//-- Ponto de entrada na gravacao
	Private lMAZ61Cpo	:= (ExistBlock('MAZ61CPO')) //-- Ponto de entrada para adicionar campos no aHeader
	Private lMAZ61Exc	:= (ExistBlock('MAZ61EXC')) //-- Ponto de entrada na gravacao do estorno
	Private lMAZ61Est	:= (ExistBlock('MAZ61EST')) //-- Ponto de entrada para verificar se estorno eh possivel
	Private lMZ61D3O	:= (ExistBlock('MZ61D3O'))	//-- Ponto de entrada para verificar se estorno eh possivel
	Private lLogMov		:= GetMV("MV_IMPMOV")
	//????????????????????????????????
	//?Pega a variavel que identifica se o calculo do custo ?:     ?
	//?              O = On-Line ou M = Mensal                      ?
	//????????????????????????????????
	Private cCusMed		:= GetMV('MV_CUSMED')
	Private nTotal		:= 0
	Private nHdlPrv		:= 0
	Private cLoteEst	:= ''
	Private cArquivo	:= ''
	Private lCriaHeade	:= .T.
	Private aRegSD3		:= {}
	Private aMemos		:= {}

	//????????????????????????????????
	//?Estas variaveis indicam para as funcoes de validacao qual    ?
	//?programa as est?chamando                                    ?
	//????????????????????????????????
	Private l240:=.F.,l241 := .F.,l242:=.F.,l250:= .F.,l261:= .T.,l185:=.F.

	//????????????????????????????????
	//?Variavel utilizada para indicar se utiliza rotina automatica ?
	//?------> NAO DEVE SER REMOVIDA <----------------------------- ?
	//????????????????????????????????
	Private lAutoma261:=Valtype(aAutoItens) == "A"
	Private nFCICalc    := SuperGetMV("MV_FCICALC",.F.,0)

	Private aLogSld   := {}

	Private aCtbDia	:= {}

	//FWAlertInfo(Alltrim(Funname()),"Atenção")

	__lIntWMS := FindFunction("IntWMS")

	If ExistBlock("MTZ61ACS")
		lAcesso := ExecBlock("MTZ61ACS",.F.,.F.)
		If ValType(lAcesso) == "L" .And. !lAcesso
			Return
		EndIf
	EndIf
	//????????????????????????????????
	//?Ponto de entrada para adicao de campos memo do usuario       ?
	//????????????????????????????????
	If ExistBlock( "MTZ61MEM" )
		aMemUser := ExecBlock( "MTZ61MEM", .F., .F. )
		If ValType( aMemUser ) == "A"
			AEval( aMemUser, { |x| AAdd( aMemos, x ) } )
		EndIf
	EndIf

	//?????????????????????????????????
	//?mv_par01 - Se mostra e permite digitar lancamentos contabeis   ?
	//?mv_par02 - Se deve aglutinar os lancamentos contabeis          ?
	//?mv_par03 - Subtrai Saldo Terc. N.Poder ? SIM/NAO               ?
	//?????????????????????????????????
	Pergunte("MTA260",.F.)

	//????????????????????????????????
	//?Verifica se o custo medio e' calculado On-Line               ?
	//????????????????????????????????
	If cCusMed == 'O'
		//????????????????????????????????
		//?Inicializa perguntas deste programa                          ?
		//????????????????????????????????
		lDigita    := Iif(mv_par01 == 1,.T.,.F.)
		lAglutina  := Iif(mv_par02 == 1,.T.,.F.)
		nTotal     := 0   //-- Total dos lancamentos contabeis
		nHdlPrv    := 0   //-- Endereco do arquivo de contra prova dos lanctos cont.
		cLoteEst   := ''  //-- Numero do lote para lancamentos do estoque
		cArquivo   := ''  //-- Nome do arquivo contra prova
		lCriaHeade := .T. //-- Para criar o header do arquivo Contra Prova

		//????????????????????????????????
		//?Posiciona numero do Lote para Lancamentos do Faturamento     ?
		//????????????????????????????????
		cLoteEst := If(SX5->(dbSeek(xFilial('SX5')+'09EST',.F.)),AllTrim(X5Descri()),'EST')
	EndIf

	//????????????????????????????????
	//?Define Array contendo as Rotinas a executar do programa      ?
	//?----------- Elementos contidos por dimensao ------------     ?
	//?1. Nome a aparecer no cabecalho                              ?
	//?2. Nome da Rotina associada                                  ?
	//?3. Usado pela rotina                                         ?
	//?4. Tipo de Transa?o a ser efetuada                          ?
	//?   1 - Pesquisa e Posiciona em um Banco de Dados             ?
	//?   2 - Simplesmente Mostra os Campos                         ?
	//?   3 - Inclui registros no Bancos de Dados                   ?
	//?   4 - Altera o registro corrente                            ?
	//?   5 - Remove o registro corrente do Banco de Dados          ?
	//????????????????????????????????
	Private aRotina := MenuDef()

	//????????????????????????????????
	//?Utiliza a funcao automatica para inclusao                    ?
	//????????????????????????????????
	If lAutoma261
		lMsHelpAuto:=.T.
		If nOpcAuto == Nil .Or. nOpcAuto == 3
			nRet := U_AZ61Inclui("SD3",SD3->(Recno()),3,aAutoItens)
		Else
			nRet := U_AZ61Estorn("SD3",SD3->(Recno()),6,aAutoItens)
		EndIf
		if nRet == 0
			lRet:=.F.
			If IsInCallStack('MATA311')
				lMsErroAuto:=.T.
			EndIf
		EndIf
		lMsHelpAuto:=.F.
	Else
		//????????????????????????????????
		//?Endereca a funcao de BROWSE                                  ?
		//????????????????????????????????
		//?????????????????????????????????
		//?Ativa tecla F12 para acionar perguntas                         ?
		//?????????????????????????????????
		SetKey( VK_F12, {|| Pergunte("MTA260")})

		//????????????????????????????????
		//?Ponto de entrada para verificacao de filtros na Mbrowse      ?
		//????????????????????????????????
		If  ExistBlock("MZ61FILB")
			cFiltro := ExecBlock("MZ61FILB",.F.,.F.)
			If Valtype(cFiltro) <> "C"
				cFiltro := ""
			EndIf
		EndIf

		mBrowse( 6, 1,22,75,"SD3",,,,,,aCores,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL))
		//?????????????????????????????????
		//?Desativa tecla que aciona perguntas                            ?
		//?????????????????????????????????
		Set Key VK_F12 To
	EndIf

Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Visual?Autor ?Marcelo Pimentel      ?Data ?04/01/98 ??
???????????????????????????????????????
??escri?o ?Programa de visualizacao de uma Transfer?cia Mod. II      ??
??         ?                                                           ??
???????????????????????????????????????
??intaxe   ?Void aZ61Visual(ExpC1,ExpN1,ExpN2)                         ??
???????????????????????????????????????
??arametros?ExpC1 = Alias do arquivo                                   ??
??         ?ExpN1 = Numero do registro                                 ??
??         ?ExpN2 = Numero da opcao selecionada                        ??
???????????????????????????????????????
??Uso      ?SigaEst                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function aZ61Visual(cAlias,nReg,nOpcX)

	Local oDlg
	Local bCampo
	Local aArea      := GetArea()
	Local aSB1Area   := SB1->(GetArea())
	Local aSD3Area   := SD3->(GetArea())
	Local nOpcao     := 5
	Local aTam       := {}
	Local cSeek      := ''
	Local cNumSeq    := ''
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosDOri	:= 2	//Descricao do Produto Origem
	Local nPosUMOri	:= 3	//Unidade de Medida Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6 	//Codigo do Produto Destino
	Local nPosDDes	:= 7	//Descricao do Produto Destino
	Local nPosUMDes	:= 8	//Unidade de Medida Destino
	Local nPosLOCDes	:= 9	//Armazem Destino
	Local nPosLcZDes	:= 10	//Localizacao Destino
	Local nPosNSer	:= 11	//Numero de Serie
	Local nPosLoTCTL 	:= 12	//Lote de Controle
	Local nPosNLOTE	:= 13	//Numero do Lote
	Local nPosDTVAL	:= 14	//Data Valida
	Local nPosPotenc 	:= 15	//Potencia do Lote
	Local nPosQUANT	:= 16	//Quantidade
	Local nPosQTSEG	:= 17	//Quantidade na 2a. Unidade de Medida
	Local nPosEstor	:= 18	//Estornado
	Local nPosNumSeq	:= 19	//Sequencia
	Local nPosLotDes	:= 20	//Lote Destino
	Local nPosDtVldD	:= 21	//Data Valida de Destino
	Local nPosPerImp	:= 0
	Local nPosCAT83O	:= 0   //Cod.CAT 83 Prod.Origem
	Local nPosCAT83D	:= 0   //Cod.CAT 83 Prod.Destino
	Local nPosServic	:= 0
	Local aButZ61		:= {}
	Local lContinua	:= .T.
	Local lCAT83		:= .F.
	Local cMemo
	Local cDescMemo
	Local nMem
	Local lExistGrade := .F.
	Local nPItem      := 0
	Local nPosCODOri  := 1
	Local lMAZ61In	:= (ExistBlock('MAZ61IN'))	//-- Atribui valores nos campos de usuario

	Private oSize
	Private aCols      := {}
	Private aHeader    := {}
	Private cDocumento := SD3->D3_DOC
	Private dAZ61Data  := SD3->D3_EMISSAO

	//??????????
	//?Portaria CAT83   |
	//??????????
	If V240CAT83()
		lCAT83:=.T.
	EndIf

	//-- Verifica se est?na filial correta
	If xFilial("SD3") # SD3->D3_FILIAL
		Help(' ',1,'A000FI')
		lContinua := .F.
	EndIf

	//-- S?Trabalha com Movimenta?es RE4/DE4
	If lContinua .And. !SD3->D3_CF $ 'RE4?E4'
		Help(' ',1,'A260NAO')
		lContinua := .F.
	EndIf
	//????????????????????????????????????
	//?Inicializa variaveis para campos Memos Virtuais						 ?
	//????????????????????????????????????
	If Type("aMemos")=="A" .And. Len(aMemos) > 0
		For nMem := 1 to Len(aMemos)
			cMemo := aMemos[nMem][2]
			cDescMemo := aMemos[nMem][3]
			If ExistIni(cMemo)
				&cMemo := InitPad(SX3->X3_RELACAO)
			Else
				&cMemo := ""
			EndIf
		Next i
	EndIf

	//????????????????????
	//?Montagem do AHeader (Visualiza?o)   ?
	//????????????????????
	If lContinua
		aHeader := {}
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0006, 'D3_COD'    , PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A261VldCod(1)', USADO, 'C', 'SD3', ''}) // 'Prod.Orig.'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0007, 'D3_DESCRI' , PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Desc.Orig.'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0008, 'D3_UM'     , PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''            , USADO, 'C', 'SD3', ''}) // 'UM Orig.'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0009, 'D3_LOCAL'  , PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'A261Almox(1)' , USADO, 'C', 'SD3', ''}) // 'Almox Orig.'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0010, 'D3_LOCALIZ', PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'A261Locali(1)', USADO, 'C', 'SD3', ''}) // 'Localiz.Orig.'
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0011, 'D3_COD'    , PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A261VldCod(2)', USADO, 'C', 'SD3', ''}) // 'Prod.Destino'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0012, 'D3_DESCRI' , PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Desc.Destino'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0013, 'D3_UM'     , PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''            , USADO, 'C', 'SD3', ''}) // 'UM Destino'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0014, 'D3_LOCAL'  , PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'A261Almox(2)' , USADO, 'C', 'SD3', ''}) // 'Almox Destino'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0015, 'D3_LOCALIZ', PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'A261Locali(2)', USADO, 'C', 'SD3', ''}) // 'Localiz.Destino'
		aTam := TamSX3('D3_NUMSERI'); Aadd(aHeader, {STR0016, 'D3_NUMSERI', PesqPict('SD3', 'D3_NUMSERI', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'N?ero Serie'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0018, 'D3_LOTECTL', PesqPict('SD3', 'D3_LOTECTL', aTam[1]         ), aTam[1], aTam[2], 'A261Lote()'   , USADO, 'C', 'SD3', ''}) // 'Lote'
		aTam := TamSX3('D3_NUMLOTE'); Aadd(aHeader, {STR0017, 'D3_NUMLOTE', PesqPict('SD3', 'D3_NUMLOTE', aTam[1]         ), aTam[1], aTam[2], 'A261Lote()'   , USADO, 'C', 'SD3', ''}) // 'Sub-Lote'
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0019, 'D3_DTVALID', PesqPict('SD3', 'D3_DTVALID', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'D', 'SD3', ''}) // 'Validade'
		aTam := TamSX3('D3_POTENCI'); Aadd(aHeader, {STR0039, 'D3_POTENCI', PesqPict('SD3', 'D3_POTENCI', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'N', 'SD3', ''}) // 'Potencia'
		aTam := TamSX3('D3_QUANT'  ); Aadd(aHeader, {STR0020, 'D3_QUANT'  , PesqPict('SD3', 'D3_QUANT'    			        ), aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Quantidade'
		aTam := TamSX3('D3_QTSEGUM'); Aadd(aHeader, {STR0021, 'D3_QTSEGUM', PesqPict('SD3', 'D3_QTSEGUM',         			), aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Qt 2aUM'
		aTam := TamSX3('D3_ESTORNO'); Aadd(aHeader, {STR0022, 'D3_ESTORNO', PesqPict('SD3', 'D3_ESTORNO', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Estornado'
		aTam := TamSX3('D3_NUMSEQ' ); Aadd(aHeader, {STR0028, 'D3_NUMSEQ' , PesqPict('SD3', 'D3_NUMSEQ' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Sequencia'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0044, 'D3_LOTECTL', PesqPict('SD3', 'D3_LOTECTL', aTam[1]         ), aTam[1], aTam[2], ''   , USADO, 'C', 'SD3', ''})
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0046, 'D3_DTVALID', PesqPict('SD3', 'D3_DTVALID', aTam[1]         ), aTam[1], aTam[2], 'A261DtPot(3)' , USADO, 'D', 'SD3', ''}) // 'Validade Destino'
		//-- Tratamento dos campos para utilizacao do SIGAWMS
		If	aZ61IntWMS()
			aTam := TamSX3('D3_SERVIC'); Aadd(aHeader, {RetTitle('D3_SERVIC'), 'D3_SERVIC', PesqPict('SD3', 'D3_SERVIC', aTam[1]      ), aTam[1], aTam[2], ''  , USADO, 'C', 'SD3', ''})
			nPosServic := aScan(aHeader,{|x| Alltrim(x[2])=="D3_SERVIC"})
		EndIf
		aTam := TamSX3('D3_ITEMGRD' ); Aadd(aHeader, {STR0055, 'D3_ITEMGRD' , PesqPict('SD3', 'D3_ITEMGRD'  , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Sequencia'
		If Type("aMemos")=="A" .And. Len(aMemos) > 0
			aTam := TamSX3(cMemo);Aadd(aHeader, {cDescMemo, cMemo, PesqPict('SD3', cMemo, aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'M', 'SD3', ''})	// CAMPOS MEMO
		EndIf

		//??????????
		//?Portaria CAT83   |
		//??????????
		If lCAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0065,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // Cod.CAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0066,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // Cod.CAT83
			nPosCAT83O  := aScan(aheader,{|x| Alltrim(x[2])=="D3_CODLAN"})
			nPosCAT83D  := IIF(nPosCAT83O>0,nPosCAT83O+1,0)
		EndIf

		//??????????
		//?Percentual FCI   |
		//??????????
		If nFCICalc == 1
			aTam := TamSX3('D3_PERIMP'  ); Aadd(aHeader, {"Per. Imp.", 'D3_PERIMP'  	, PesqPict('SD3', 'D3_PERIMP'), aTam[1], aTam[2], 'A250VlPImp()', USADO, 'N', 'SD3', ''}) // 'Percentual Importacao'
			nPosPerImp  := aScan(aheader,{|x| Alltrim(x[2])=="D3_PERIMP"})    //Percental Importacao
		EndIf

		//-- ExecBlock para incluir campos no aHeader
		If lMAZ61Cpo
			ExecBlock('MAZ61CPO',.F.,.F.)
		EndIf

		ADHeadRec("SD3",aHeader)

		//-- Posicionamento das Ordens utilizadas na fun?o
		SB1->(dbSetOrder(1))
		SD3->(dbSetOrder(8))

		//????????????????????
		//?Montagem do ACols (Visualiza?o)     ?
		//????????????????????
		aCols   := {}
		cNumSeq := '?
		nPItem:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_ITEMGRD"})

		If !SD3->(dbSeek( cSeek := xFilial('SD3')+cDocumento,.F.))
			Help(' ',1,'A260NAO')
			lContinua := .F.
		EndIf
	EndIf
	Do While lContinua .And. !SD3->(Eof()) .And. cSeek == SD3->D3_FILIAL+SD3->D3_DOC

		If SD3->D3_CF $ 'RE4?E4'
			aAdd(aCols, Array(Len(aHeader)))
			cNumSeq := SD3->D3_NUMSEQ
		Else
			SD3->(dbSkip())
			Loop
		EndIf

		Do While !SD3->(Eof()) .And. cNumSeq == SD3->D3_NUMSEQ

			If SD3->D3_CF $ 'RE4'

				//-- Posiciona o Arquivo de Produtos (SB1)
				If !SB1->(dbSeek(xFilial('SB1')+SD3->D3_COD,.F.))
					Help(' ', 1, 'REGNOIS')
					lContinua := .F.
					Exit
				EndIf
				aCols[Len(aCols),nPosCODOri]   	:= SD3->D3_COD
				aCols[Len(aCols),nPosDOri]     	:= SB1->B1_DESC
				aCols[Len(aCols),nPosUMOri]    	:= SD3->D3_UM
				aCols[Len(aCols),nPosLOCOri]   	:= SD3->D3_LOCAL
				aCols[Len(aCols),nPosQUANT]    	:= SD3->D3_QUANT
				aCols[Len(aCols),nPosQTSEG]    	:= SD3->D3_QTSEGUM
				aCols[Len(aCols),nPosEstor]    	:= SD3->D3_ESTORNO
				aCols[Len(aCols),nPosNumSeq]   	:= cNumSeq
				aCols[Len(aCols),nPItem]       	:= SD3->D3_ITEMGRD
				aCols[Len(aCols),nPosLcZOri]	:= SD3->D3_LOCALIZ
				aCols[Len(aCols),nPosNSer]  	:= SD3->D3_NUMSERI
				aCols[Len(aCols),nPosLoTCTL]	:= SD3->D3_LOTECTL
				aCols[Len(aCols),nPosNLOTE] 	:= SD3->D3_NUMLOTE
				aCols[Len(aCols),nPosDTVAL] 	:= SD3->D3_DTVALID
				aCols[Len(aCols),nPosPotenc]	:= SD3->D3_POTENCI

				If nPosCAT83O>0
					aCols[Len(aCols),nPosCAT83O]:= SD3->D3_CODLAN
				EndIf

			ElseIf SD3->D3_CF $ 'DE4'
				//-- Posiciona o Arquivo de Produtos (SB1)
				If !SB1->(dbSeek(xFilial('SB1')+SD3->D3_COD,.F.))
					Help(' ', 1, 'REGNOIS')
					lContinua := .F.
					Exit
				EndIf
				aCols[Len(aCols),nPosCODDes]	:= SD3->D3_COD
				aCols[Len(aCols),nPosDDes]		:= SB1->B1_DESC
				aCols[Len(aCols),nPosUMDes]		:= SD3->D3_UM
				aCols[Len(aCols),nPosLOCDes]	:= SD3->D3_LOCAL
				aCols[Len(aCols),nPosLcZDes]	:= SD3->D3_LOCALIZ
				aCols[Len(aCols),nPosLotDes]	:= SD3->D3_LOTECTL
				aCols[Len(aCols),nPosDtVldD]	:= SD3->D3_DTVALID
				If	nPosServic > 0
					aCols[Len(aCols),nPosServic] := SD3->D3_SERVIC
				EndIf

				If nPosCAT83D>0
					aCols[Len(aCols),nPosCAT83D]:= SD3->D3_CODLAN
				EndIf
				If nFCICalc == 1
					aCols[Len(aCols),nPosPerImp]:= SD3->D3_PERIMP
				EndIf
			EndIf

			aCols[Len(aCols)][Len(aHeader)-1] := "SD3"
			aCols[Len(aCols)][Len(aHeader)]	  := SD3->(RecNo())

			SD3->(dbSkip())
			If !Empty(aCols[Len(aCols),nPosCODOri]) .And. !Empty(aCols[Len(aCols),nPosCODDes])
				Exit
			EndIf
		EndDo
		If !lContinua
			Exit
		EndIf
		If Empty(aCols[Len(aCols),nPosCODOri]) .Or. Empty(aCols[Len(aCols),nPosCODDes])
			Help(' ',1,'A260NAO')
			lContinua := .F.
			Exit
		EndIf
		//-- ExecBlock para atribuir valores nos campos de usuario
		If lMAZ61In
			ExecBlock('MAZ61IN',.F.,.F.)
		EndIf
	EndDo

	If lContinua .And. Len(aCols) == 0
		Help(' ',1,'A240ESTORN')
		lContinua := .F.
	EndIf

	If lContinua
		//????????????????????????????????
		//?Calcula dimens?s                                            ?
		//????????????????????????????????
		oSize := FwDefSize():New()

		oSize:AddObject( "CIMA"  ,  100,  5, .T., .T.) // Nao dimensiona Y
		oSize:AddObject( "BAIXO",  100, 95, .T., .T.) // Totalmente dimensionavel

		oSize:lProp := .T. // Proporcional
		oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

		oSize:Process() // Dispara os calculos
		//????????????????????????????????
		//?Executa ponto de entrada para montar array com botoes a      ?
		//?serem apresentados na tela                                   ?
		//????????????????????????????????
		If (ExistBlock("MZ61BCHOI"))
			aButZ61:=ExecBlock("MZ61BCHOI",.F.,.F.)
			If ValType(aButZ61) # "A"
				aButZ61:={}
			EndIf
		EndIf
		//????????????????????????????????
		//?Monta Dialog                                                 ?
		//????????????????????????????????
		DEFINE MSDIALOG oDlg TITLE cCadastro ;  //"Transferencia Mod2"
			FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL
		//????????????????????????????????
		//?Adiciona Panel                                               ?
		//????????????????????????????????
		oPanel1:= tPanel():New(oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI"),,oDlg,,,,,,oSize:GetDimension("CIMA","XSIZE"),oSize:GetDimension("CIMA","YSIZE"),,)
		oPanel2:= tPanel():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),,oDlg,,,,,,oSize:GetDimension("BAIXO","XSIZE"),oSize:GetDimension("BAIXO","YSIZE"),,)

		@ 0,0 SAY   OemToAnsi("Numero da OP") OF oPanel1 PIXEL // 'N?ero Documento'
		@ 0,50 MSGET cDocumento When .F. SIZE 70,08 OF oPanel1 PIXEL
		@ 0,125 SAY   OemToAnsi(STR0024) OF oPanel1 PIXEL // 'Emiss?'
		@ 0,150 MSGET dAZ61Data When .F. SIZE 40,08 OF oPanel1 PIXEL

		//????????????????????????????????
		//?onto de Entrada que disponibiliza o Objeto da Dialog        ?
		//????????????????????????????????
		If (ExistBlock( "MTZ61CAB" ))
			ExecBlock("MTZ61CAB",.F.,.F.,{@oPanel1,oSize:aPosObj[1,1],nOpcx})
		EndIf

		oGet := MSGetDados():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),oSize:GetDimension("BAIXO","LINEND"),oSize:GetDimension("BAIXO","COLEND"),;
			nOpcX,'AllwaysTrue','AllwaysTrue','',;
			.F.,{"D3_QUANT","D3_QTSEGUM"},NIL,NIL,;
			LINHAS,,,,,,,,,oPanel2)

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End(),If(oGet:TudoOK(),nOpca:=1,nOpca:=0)},{||oDlg:End()},,aButZ61)
	EndIf
	//-- Retorna a integridade do Sistema
	RestArea(aSB1Area)
	RestArea(aSD3Area)
	RestArea(aArea)
Return NIL


/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Inclui?Autor ?Marcelo Pimentel      ?Data ?29/01/98 ??
???????????????????????????????????????
??escri?o ?Programa de Transferencia Mod. II                          ??
??         ?                                                           ??
???????????????????????????????????????
??intaxe   ?Void aZ61Inclui(ExpC1,ExpN1,ExpN2,ExpA1)                   ??
???????????????????????????????????????
??arametros?ExpC1 = Alias do arquivo                                   ??
??         ?ExpN1 = Numero do registro                                 ??
??         ?ExpN2 = Opcao selecionada                                  ??
??         ?ExpA1 = Array com dados da rotina automatica               ??
???????????????????????????????????????
??Uso      ?Generico                                                   ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function aZ61Inclui(cAlias,nReg,nOpcX,aAutoItens)

	Local bCampo
	Local aArea      := GetArea()
	Local aAreaDH1	 := {}
	Local aSB1Area   := SB1->(GetArea())
	Local aSD3Area   := SD3->(GetArea())
	Local nOpcao     := 3
	Local dDataFec   := MVUlmes()
	Local aAlter     := {}
	Local nSavReg    := 0
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	Local cStrErr    := ""
	Local aAreaAnt   := {}
	Local lQualyCQ   := .F.
	Local lOkAutoma  := .T.
	Local lCAT83  	 := .F.
	Local oDlg
	Local nx,nz
	Local cDescMemo
	Local cMemo
	Local nMem
	Local cCampo     := ""
	Local nPosCODDes := 6	//Codigo do Produto Destino
	Local nPosLOCDes := 9	//Armazem Destino
	Local cTextoAutoma:=STR0038
	Local nw
	Local aButZ61		:= {}
	Local lContinua		:= .T.
	Local lChangeDoc	:= .F.
	Local nPosCODOri	:= 1	//Codigo do Produto Destino
	Local nPosHeader	:= 0
	Local aHeaderBKP	:= {}
	Local aRecSD3 		:= {}
	Local lMAZ61TRD3	:= ExistBlock("MAZ61TRD3")
	Local cDocWMS    := ""
	Local lIntegDef		:= FWHasEAI("MATAZ61",.T.,,.T.)
	Local lWmsNew	 := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local oOrdServ	 := Nil
	Local lMAZ61In	:= (ExistBlock('MAZ61IN'))	//-- Atribui valores nos campos de usuario
	Local lDocto	:= IIf( GetSx3Cache("D3_DOC","X3_VISUAL") == "V", .F., IIf( Empty( GetSx3Cache( "D3_DOC", "X3_WHEN" ) ), .T.,&( GetSx3Cache( "D3_DOC", "X3_WHEN" ) ) ) )

	Private oSize
	Private cDocumento := CriaVar('D3_DOC')
	Private cOP        := CriaVar('D3_OP')
	Private dAZ61Data  := dDataBase
	Private nOpca      := 0
	Private nPosZ61Loc := 10
	Private nPosNSer   := 11
	Private nPosLotCTL := 12
	Private nPosLote   := 13
	Private nPosDValid := 14
	Private nPosZ61Loc := 05
	Private nPosZ61Qtd := 16
	Private nPosLotDes := 20	//Lote Destino
	Private nPosZ61Pot := 15	//Potencia
	Private nPosDtVldD := 21	//Data Valida de Destino
	Private aCols      := {}
	Private aHeader    := {}

	//-- Variaveis utilizadas pela funcao wmsexedcf
	Private aLibSDB    := {}
	Private aWmsAviso  := {}


	INCLUI := .T. //Vari?el criada pois quando a fun?o incluir ?acionada por MsExecAuto a mesma n? ?criada
	ALTERA := .F. //Vari?el criada pois quando a fun?o incluir ?acionada por MsExecAuto a mesma n? ?criada

	//Tratamento para Carregar os parametros do Pergunte
	Pergunte("MTA260",.F.)

	//??????????
	//?Portaria CAT83   |
	//??????????
	If V240CAT83()
		lCAT83:=.T.
	EndIf

	//????????????????????????????????
	//?Verifica a Existencia do ponto de entrada e seta valor       ?
	//?da variavel que define se edita o documento ou nao           ?
	//????????????????????????????????
	If ExistBlock("MTAZ61DOC")
		lDocto := ExecBlock("MTAZ61DOC",.F.,.F.)
		lDocto := If(Valtype(lDocto)#"L",.T.,lDocto)
	EndIf

	//-- Verificar data do ultimo fechamento em SX6
	If dDataFec >= dDataBase
		Help (' ', 1, 'FECHTO')
		lContinua := .F.
	EndIf

	//????????????????????????????????????
	//?Inicializa variaveis para campos Memos Virtuais                  	 ?
	//????????????????????????????????????
	If Type("aMemos")=="A" .And. Len(aMemos) > 0
		For nMem :=1 To Len(aMemos)
			cMemo := aMemos[nMem][2]
			cDescMemo := aMemos[nMem][3]
			If ExistIni(cMemo)
				&cMemo := InitPad(SX3->X3_RELACAO)
			Else
				&cMemo := ""
			EndIf
		Next nMem
	EndIf
	If lContinua
		//-- Verificar integracao com rotina automatica
		If lAutoma261
			cDocumento:=If(ValType(aAutoItens[1,1])=="C",aAutoItens[1,1],"")
			dAZ61Data:=If(ValType(aAutoItens[1,2])=="D",aAutoItens[1,2],dDataBase)
		EndIf

		//-- Inicializa o numero do Documento com o ultimo + 1
		dbSelectArea(cAlias)
		nSavReg		:= RecNo()
		cDocumento	:= IIf(Empty(cDocumento),NextNumero("SD3",2,"D3_DOC",.T.),cDocumento)
		// Busca proximo documento na tabela auxiliar (DH1) quando controla novo WMS
		If !lAutoma261 .And. lWmsNew
			aAreaDH1 := GetArea()
			dbSelectArea("DH1")
			DH1->(dbSetOrder(2))
			If DH1->(dbSeek(xFilial("DH1")+cDocumento))
				cDocWms	:= NextNumero("DH1",2,"DH1_DOC",.T.)
				cDocumento := cDocWms
			EndIf
			RestArea(aAreaDH1)
		EndIf
		cDocumento := AZ61RetINV(cDocumento)
		dbSetOrder(2)
		dbSeek(xFilial()+cDocumento)
		cMay := "SD3"+Alltrim(xFilial())+cDocumento
		While D3_FILIAL+D3_DOC==xFilial()+cDocumento.Or.!MayIUseCode(cMay)
			If D3_ESTORNO # "S"
				cDocumento := Soma1(cDocumento)
				cMay := "SD3"+Alltrim(xFilial())+cDocumento
			EndIf
			dbSkip()
		EndDo
		dbSetOrder(1)
		dbGoTo(nSavReg)

		//-- Monta o array com os campos que poder? ser alterados
		Aadd(aAlter, 'D3_COD')
		Aadd(aAlter, 'D3_LOCAL')
		Aadd(aAlter, 'D3_QUANT')
		Aadd(aAlter, 'D3_LOCALIZ')
		Aadd(aAlter, 'D3_NUMSERI')
		Aadd(aAlter, 'D3_NUMLOTE')
		Aadd(aAlter, 'D3_LOTECTL')
		Aadd(aAlter, 'D3_DTVALID')
		Aadd(aAlter, 'D3_POTENCI')
		Aadd(aAlter, 'D3_QTSEGUM')

		//????????????????????
		//?Montagem do AHeader (Inclus?)       ?
		//????????????????????
		aHeader := {}
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0006, 'D3_COD'    	, PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A093Prod().And.U_AZ61PrdGrd().And.A261VldCod(1)', USADO, 'C', 'SD3', ''})	// 'Prod.Orig.'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0007, 'D3_DESCRI' 	, PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''})	// 'Desc.Orig.'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0008, 'D3_UM'     	, PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''})	// 'UM Orig.'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0009, 'D3_LOCAL'  	, PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Almox(1)' , USADO, 'C', 'SD3', ''})	// 'Almox Orig.'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0010, 'D3_LOCALIZ'	, PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Locali(1)', USADO, 'C', 'SD3', ''})	// 'Localiz.Orig.'
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0011, 'D3_COD'    	, PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A093Prod().And.U_AZ61PrdGrd().And.A261VldCod(2)', USADO, 'C', 'SD3', ''}) // 'Prod.Destino'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0012, 'D3_DESCRI' 	, PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Desc.Destino'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0013, 'D3_UM'     	, PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'UM Destino'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0014, 'D3_LOCAL'  	, PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Almox(2)' , USADO, 'C', 'SD3', ''}) // 'Almox Destino'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0015,'D3_LOCALIZ'	, PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Locali(2)', USADO, 'C', 'SD3', ''}) // 'Localiz.Destino'
		aTam := TamSX3('D3_NUMSERI'); Aadd(aHeader, {STR0016,'D3_NUMSERI'	, PesqPict('SD3', 'D3_NUMSERI', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'N?ero Serie'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0018,'D3_LOTECTL'	, PesqPict('SD3', 'D3_LOTECTL', aTam[1]     )	, aTam[1], aTam[2], 'AZ61Lote(1)'  , USADO, 'C', 'SD3', ''}) // 'Lote'
		aTam := TamSX3('D3_NUMLOTE'); Aadd(aHeader, {STR0017,'D3_NUMLOTE'	, PesqPict('SD3', 'D3_NUMLOTE', aTam[1]     )	, aTam[1], aTam[2], 'AZ61Lote(1)'  , USADO, 'C', 'SD3', ''}) // 'Sub-Lote'
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0019,'D3_DTVALID'	, PesqPict('SD3', 'D3_DTVALID', aTam[1]     )	, aTam[1], aTam[2], 'AZ61DtPot(1)' , USADO, 'D', 'SD3', ''}) // 'Validade'
		aTam := TamSX3('D3_POTENCI'); Aadd(aHeader, {STR0039,'D3_POTENCI'	, PesqPict('SD3', 'D3_POTENCI', aTam[1]     )	, aTam[1], aTam[2], 'AZ61DtPot(2)' , USADO, 'N', 'SD3', ''}) // 'Potencia'
		aTam := TamSX3('D3_QUANT'  ); Aadd(aHeader, {STR0020, 'D3_QUANT'  	, PesqPict('SD3', 'D3_QUANT'   			         ), aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Quantidade'
		aTam := TamSX3('D3_QTSEGUM'); Aadd(aHeader, {STR0021, 'D3_QTSEGUM'	, PesqPict('SD3', 'D3_QTSEGUM'	         		 ), aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Qt 2aUM'
		aTam := TamSX3('D3_ESTORNO'); Aadd(aHeader, {STR0022, 'D3_ESTORNO'	, PesqPict('SD3', 'D3_ESTORNO', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Estornado'
		aTam := TamSX3('D3_NUMSEQ' ); Aadd(aHeader, {STR0028, 'D3_NUMSEQ' 	, PesqPict('SD3', 'D3_NUMSEQ' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Sequencia'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0044, 'D3_LOTECTL', PesqPict('SD3', 'D3_LOTECTL', aTam[1]      ), aTam[1], aTam[2], 'AZ61Lote(2)'  , USADO, 'C', 'SD3', ''})
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0046,'D3_DTVALID'	, PesqPict('SD3', 'D3_DTVALID', aTam[1]     ), aTam[1], aTam[2], 'AZ61DtPot(3)' , USADO, 'D', 'SD3', ''}) // 'Validade Destino'
		//-- Tratamento dos campos para utilizacao do SIGAWMS
		If	aZ61IntWMS()
			aTam := TamSX3('D3_SERVIC'); Aadd(aHeader, {RetTitle('D3_SERVIC'), 'D3_SERVIC', PesqPict('SD3', 'D3_SERVIC', aTam[1]      ), aTam[1], aTam[2], ''  , USADO, 'C', 'SD3', ''})
		EndIf
		aTam := TamSX3('D3_ITEMGRD'); Aadd(aHeader, {STR0055,'D3_ITEMGRD'	, PesqPict('SD3', 'D3_ITEMGRD', aTam[1]         ), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // 'Validade Destino'

		//??????????
		//?Portaria CAT83   |
		//??????????
		If lCAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0065,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], "Vazio() .Or. ExistCpo('CDZ')" , USADO, 'C', 'SD3', ''}) // Cod.CAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0066,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], "Vazio() .Or. ExistCpo('CDZ')" , USADO, 'C', 'SD3', ''}) // Cod.CAT83
		EndIf
		//??????????
		//?Percentual FCI   |
		//??????????
		If nFCICalc == 1
			aTam := TamSX3('D3_PERIMP'  ); Aadd(aHeader, {RetTitle('D3_PERIMP'), 'D3_PERIMP'  	, PesqPict('SD3', 'D3_PERIMP'), aTam[1], aTam[2], 'A250VlPImp()', USADO, 'N', 'SD3', ''}) // 'Percentual Importacao'
		EndIf

		If Type("aMemos")=="A" .And. Len(aMemos) > 0
			aTam := TamSX3(cMemo);Aadd(aHeader, {cDescMemo, cMemo, PesqPict('SD3', cMemo, aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'M', 'SD3', ''})	// CAMPOS MEMO
		EndIf

		If SD3->(FieldPos("D3_IDDCF"))>0 .And. aZ61IntWMS()
			aTam := TamSX3('D3_IDDCF'); Aadd(aHeader, {RetTitle('D3_IDDCF'),'D3_IDDCF', PesqPict('SD3','D3_IDDCF', aTam[1]), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // Id DCF
		EndIf
		if lAutoma261
			aTam := TamSX3('D3_OBSERVA'); Aadd(aHeader, {RetTitle('D3_OBSERVA'), 'D3_OBSERVA', PesqPict('SD3', 'D3_OBSERVA', aTam[1] ), aTam[1], aTam[2], , USADO, 'C', 'SD3', ''})
		Endif

		//??????????????????????????????????
		//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
		//??????????????????????????????????

		//-- ExecBlock para incluir campos no aHeader
		If lMAZ61Cpo
			ExecBlock('MAZ61CPO',.F.,.F.)
		EndIf

		aCols := {}
		//-- Verificar integracao com rotina automatica
		If lAutoma261
			// Varre o array consistindo se os valores passados pelo usuario estao corretos
			// com relacao ao seu tipo
			// O item 1 do array contem o cabecalho para a rotina, nao deve ser considerado
			For nz:=2 to Len(aAutoItens)
				If ValType(aAutoItens[nz,Len(aAutoItens[nz])])#"D" .And. Len(aAutoItens[nz]) < 21
					Aadd(aAutoItens[nz], If(ValType(aAutoItens[nz,14])=="D",aAutoItens[nz,14],If(Empty(aAutoItens[nz,12]),CTOD(''),dDataBase)) )
				EndIf
				If Len(aAutoItens[nz,1]) == 3
					aAdd(aCols, Array(Len(aHeader)+1))
					aHeaderBKP := aClone(aHeader)
					For nX := 1 To Len(aAutoItens[nz])
						nPosHeader:=	aScan(aHeaderBKP,{|x| Alltrim(x[2])==aAutoItens[nz,nX,1]})
						If !Empty(nPosHeader)
							aCols[Len(aCols),nPosHeader]:=aAutoItens[nz,nX,2]
							aHeaderBKP[nPosHeader,2]:= "X"
						EndIf
					Next nX
					aCols[Len(aCols),Len(aHeader)+1] := .F.
				ElseIf Len(aAutoItens[nz]) # Len(aHeader)
					cTextoAutoma:=STR0040+chr(13)+chr(10)
					cTextoAutoma+=STR0041+chr(13)+chr(10)
					cTextoAutoma+=STR0042+chr(13)+chr(10)
					cTextoAutoma+="---------- ---------- ---- ------- -------"+chr(13)+chr(10)
					For nw:= 1 to len(aHeader)
						cTextoAutoma+=Padr(aHeader[nw,1],10)+" "+padr(aHeader[nw,2],10)+"  "+aHeader[nw,8]+"   "+Str(aHeader[nw,4],7)+" "+Str(aHeader[nw,5],7)+chr(13)+chr(10)
					Next
					lOkAutoma:=.F.
					Exit
				Else
					aAdd(aCols, Array(Len(aHeader)+1))
					For nX := 1 To Len(aHeader)
						If !ValType(aAutoItens[nz,nx]) == aHeader[nX,8]
							lOkAutoma:=.F.
							cStrErr  :=" "+Str(nx)
							cTextoAutoma+=cStrErr
						Else
							aCols[Len(aCols),nx]:=aAutoItens[nz,nx]
						EndIf
					Next nX
					aCols[Len(aCols),Len(aHeader)+1] := .F.
				EndIf
			Next nz
		Else

			ADHeadRec(cAlias,aHeader)

			//????????????????????
			//?Montagem do ACols (Visualiza?o)     ?
			//????????????????????
			aAdd(aCols, Array(Len(aHeader)+1))
			For nX := 1 To Len(aHeader)
				cCampo:=Alltrim(aHeader[nX,2])
				If IsHeadRec(aHeader[nX][2])
					aCols[1][nX] := 0
				ElseIf IsHeadAlias(aHeader[nX][2])
					aCols[1][nX] := cAlias
				ElseIf aHeader[nX,8] == 'C'
					aCols[1,nX] := Space(aHeader[nX,4])
				ElseIf aHeader[nX,8] == 'N'
					aCols[1,nX] := 0
				ElseIf aHeader[nX,8] == "D" .And. cCampo != "D3_DTVALID"
					aCols[1][nX] := dDataBase
				ElseIf aHeader[nX,8] == "D" .And. cCampo == "D3_DTVALID"
					aCols[1][nX] := CriaVar("D3_DTVALID")
				ElseIf aHeader[nX,8] == 'M'
					aCols[1,nX] := ''
				Else
					aCols[1,nX] := .F.
				EndIf
			Next nX
			aCols[1,Len(aHeader)+1] := .F.
		EndIf

		//-- ExecBlock para atribuir valores nos campos de usuario
		If lMAZ61In
			ExecBlock('MAZ61IN',.F.,.F.)
		EndIf
		//????????????????????????????????
		//?Calcula dimens?s                                            ?
		//????????????????????????????????
		oSize := FwDefSize():New()

		oSize:AddObject( "CIMA"  ,  100,  5, .T., .T.) // Nao dimensiona Y
		oSize:AddObject( "BAIXO",  100, 95, .T., .T.) // Totalmente dimensionavel

		oSize:lProp := .T. // Proporcional
		oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

		oSize:Process() // Dispara os calculos

		If lAutoma261
			//?????????????????????
			//?Valida o cabecalho passado pela rotina?
			//?automatica, a integridade do tipo de  ?
			//?dado alimentado no array da rotina    ?
			//?automatica e valida a getdados como se?
			//?os dados tivessem sido digitados.     ?
			//?????????????????????
			If lOkAutoma
				lOkAutoma:=lOkAutoma .And. (dDataFec < dAZ61Data) .And. A240Doc()
				For nw:=1 to Len(aCols)
					If !lOkAutoma
						Exit
					EndIf
					N := nw //-- Inicializa a variavel "N" utilizada para definir a linha atual do aCols
					lOkAutoma:=U_A261Linok(nil,nw) .And. U_A261Tudook(nil,nw)
				Next nw
				If lOkAutoma
					nOpcA := 1
				EndIf
			Else
				Help(" ",1,STR0037,STR0037,cTextoAutoma,05,01)
			EndIf
		Else
			//????????????????????????????????
			//?Executa ponto de entrada para montar array com botoes a      ?
			//?serem apresentados na tela                                   ?
			//????????????????????????????????
			If (ExistBlock("MZ61BCHOI"))
				aButZ61:=ExecBlock("MZ61BCHOI",.F.,.F.)
				If ValType(aButZ61) # "A"
					aButZ61:={}
				EndIf
			EndIf

			Set Key VK_F4 TO ShowF4()


			//????????????????????????????????
			//?Monta Dialog                                                 ?
			//????????????????????????????????
			DEFINE MSDIALOG oDlg TITLE "Transferência Empenhos" ;  //"Transferencia Mod2"
				FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL
			//????????????????????????????????
			//?Adiciona Panel                                               ?
			//????????????????????????????????
			oPanel1:= tPanel():New(oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI"),,oDlg,,,,,,oSize:GetDimension("CIMA","XSIZE"),oSize:GetDimension("CIMA","YSIZE"),,)
			oPanel2:= tPanel():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),,oDlg,,,,,,oSize:GetDimension("BAIXO","XSIZE"),oSize:GetDimension("BAIXO","YSIZE"),,)

			@ 00 ,0  SAY   OemToAnsi("Numero do Documento") OF oPanel1 PIXEL // 'N?ero Documento'
			@ 00 ,50 MSGET cDocumento Picture PesqPict('SD3','D3_DOC') Valid A240Doc() WHEN lDocto SIZE 70,08  OF oPanel1 PIXEL
			//@ 00, 50 MSGET cDocumento Picture PesqPict('SD3','D3_DOC') VALID  U_AZ61Doc(oGet,aCols,cDocumento,nOpcX,oDlg) F3 "SC2" SIZE 70, 08 OF oPanel1 PIXEL
			@ 00 ,125 SAY   OemToAnsi(STR0024) OF oPanel1 PIXEL // 'Emiss?'
			@ 00 ,150 MSGET dAZ61Data Valid MaZ61VldDt(dDataFec, dAZ61Data) WHEN If(GetSx3Cache("D3_EMISSAO","X3_VISUAL") == "V",.F.,&(GetSx3Cache("D3_EMISSAO","X3_WHEN"))) SIZE 40,08  OF oPanel1 PIXEL
			@ 00 ,195 SAY   OemToAnsi("OP") OF oPanel1 PIXEL
			@ 00, 215 MSGET cOP Picture PesqPict('SD4','D4_OP') VALID  U_AZ61Doc(oGet,aCols,cOP,nOpcX,oDlg) F3 "SC2" SIZE 70, 08 OF oPanel1 PIXEL
			@ 00, 300 BUTTON oBtn1 PROMPT "Preencher" SIZE 35,12 ACTION U_Preenche(oGet,aCols,cOP,nOpcX,oDlg) OF oPanel1 PIXEL
			//@ 00, 270 BUTTON btnOutros PROMPT "Preencher" SIZE 100, 50 OF oDlg PIXEL ACTION U_Preenche(oGet,aCols,cOP,nOpcX,oDlg)

			//????????????????????????????????
			//?onto de Entrada que disponibiliza o Objeto da Dialog        ?
			//????????????????????????????????
			If (ExistBlock( "MTZ61CAB" ))
				ExecBlock("MTZ61CAB",.F.,.F.,{@oPanel1,oSize:aPosObj[1,1],nOpcx})
			EndIf

			oGet := MSGetDados():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),oSize:GetDimension("BAIXO","LINEND"),oSize:GetDimension("BAIXO","COLEND"),;
				nOpcX,'U_AZ61LINOK','U_AZ61TUDOOK','',;
				.T.,NIL,NIL,NIL,;
				LINHAS,,,,,,,,,oPanel2)

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||IIf(oGet:TudoOK(),(oDlg:End(),nOpca:=1),nOpca := 0)},{||oDlg:End()},,aButZ61)
			Set Key VK_F4 to
		EndIf

		If nOpcA == 1
			//-- Verifica se algum produto utiliza CQ Celerina
			lQualyCQ := .F.
			For nX := 1 to Len(aCols)
				If SB1->(dbSeek(xFilial('SB1') + aCols[nX, nPosCODDes], .F.)) .And. ;
						RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == 'Q' .And. aCols[nX, nPosLOCDes] == cLocCQ
					lQualyCQ := .T.
					dbSelectArea("QE6")
					QE6->(dbSetOrder(3))
					If !QE6->(dbSeek(xFilial("QE6")+SB1->B1_COD))
						HELP(" ",1,"QIPXFATIPCQ")
						Return NIL
					Endif
					QE6->(dbCloseArea())
					Exit
				EndIf
			Next nX

			Begin Transaction
				u_aZ61Grava(cAlias,nOpcao,@lChangeDoc,@aRecSD3,aAutoItens)
				// Processa Gatilhos
				EvalTrigger()
				If __lSX8
					ConfirmSX8()
				EndIf
				//-- Integra?o Mensagem ?ica
				If lIntegDef
					FwIntegDef("MATAZ61",,,,"MATAZ61")
				EndIf
				aRegSD3 := {}
			End Transaction

			If lMAZ61TRD3
				ExecBlock("MAZ61TRD3",.F.,.F.,{aRecSD3})
			EndIf

			If lChangeDoc .And. !lAutoma261
				Help("",1,"A240DOC",,cDocumento,4,30)
			EndIf

			If lLogMov .And. Len(aLogSld) > 0
				//???????????????????????????????????
				//?Imprimir Relatorio de Movimentos nao realizados por falta de saldo ?
				//???????????????????????????????????
				RelLogMov(aLogSld)
			EndIf
			aSD3Area[3] := SD3->(Recno())
			//-- Integrado ao wms devera avaliar as regras para convocacao do servico e disponibilizar os
			//-- registros do SDB para convocacao, ou exibir as mensagens de erro WMS caso necess?io
			If IntWMS()
				WmsAvalSD3("2","SD3")
			EndIf
		Else
			If __lSX8
				RollBackSX8()
			EndIf
			//????????????????????????????????
			//?xecuta P.E. ao sair sem gravar 				                 ?
			//????????????????????????????????
			If (ExistBlock("MTAZ61CAN"))
				ExecBlock("MTAZ61CAN",.F.,.F.,{nOpcx})
			EndIf
		EndIf
	EndIf
	//-- Retorna a integridade do Sistema
	RestArea(aSB1Area)
	RestArea(aSD3Area)
	RestArea(aArea)

Return nOpcA

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Estorn?Autor ?Marcelo Pimentel      ?Data ?02/02/98 ??
???????????????????????????????????????
??escri?o ?Programa de exclusao de transferencias Mod. II             ??
???????????????????????????????????????
??intaxe   ?AZ61Estorn(ExpC1,ExpN1,ExpN2)                              ??
???????????????????????????????????????
??arametros?ExpC1 = Alias do arquivo                                   ??
??         ?ExpN1 = Numero do registro                                 ??
??         ?ExpN2 = Numero da opcao selecionada                        ??
???????????????????????????????????????
??Uso      ?Sigaest                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function AZ61Estorn(cAlias,nReg,nOpcX, aAutoItens)
	LOCAL dDataFec   := MVUlmes()
	Local aArea      := GetArea()
	Local aArea2 	:= {}
	Local aAreaSD3	:= {}
	Local aSB1Area   := SB1->(GetArea())
	Local aSD3Area   := SD3->(GetArea())
	Local aSD7Area   := SD7->(GetArea())
	Local bCampo     := {|nCPO| Field(nCPO) }
	Local cSaveMenuh := ''
	Local nOpcao     := 5
	Local aAlter     := {"D3_QUANT","D3_QTSEGUM"}
	Local nPos       := 0
	Local nCnt       := 0
	Local nX         := 0
	Local nY         := 0
	Local cSeek      := ''
	Local cNumSeq    := ''
	Local cCFAnt     := ''
	Local aRecnos    := {}
	Local aDelSD7    := {}
	Local nDelSD7    := 0
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	Local lEstQualy  := .F.
	Local nSC7OrdAnt := 0
	Local nSC7RecAnt := 0
	Local oDLG
	Local cDescMemo
	Local cMemo
	Local nMem
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosEstor  	:= 1	//Estornado
	Local nPosCODOri 	:= 2 	//Codigo do Produto Origem
	Local nPosDOri	:= 3	//Descricao do Produto Origem
	Local nPosUMOri	:= 4	//Unidade de Medida Origem
	Local nPosLOCOri	:= 5	//Armazem Origem
	Local nPosLcZOri	:= 6	//Localizacao Origem
	Local nPosCODDes	:= 7	//Codigo do Produto Destino
	Local nPosDDes	:= 8	//Descricao do Produto Destino
	Local nPosUMDes	:= 9	//Unidade de Medida Destino
	Local nPosLOCDes	:= 10	//Armazem Destino
	Local nPosLcZDes	:= 11	//Localizacao Destino
	Local nPosNSer	:= 12	//Numero de Serie
	Local nPosLoTCTL	:= 13	//Lote de Controle
	Local nPosNLOTE	:= 14	//Numero do Lote
	Local nPosDTVAL	:= 15	//Data Valida
	Local nPosPotenc	:= 16	//Potencia
	Local nPosQUANT	:= 17	//Quantidade
	Local nPosQTSEG	:= 18	//Quantidade na 2a. Unidade de Medida
	Local nPosNumSeq	:= 19	//Sequencia
	Local nPosLotDes	:= 20	//Lote Destino
	Local nPosDtVldD	:= 21	//Data Validade Destino
	Local nPosCAT83O	:= 0	//Cod.CAT 83 Prod.Origem
	Local nPosCAT83D	:= 0   //Cod.CAT 83 Prod.Destino
	Local nPosServic	:= 0
	Local nPosPerImp	:= 0

	Local oSize
	Local cLotCtlQie	:= ''
	Local cNumLotQie	:= ''
	Local lVldEst		:= .F.
	Local lCAT83		:= .F.
	Local aButZ61		:= {}
	Local aLockSB2		:= {}
	Local aLockSD3		:= {}
	Local lContinua		:= .T.
	Local cServico		:= ''
	Local aCtbDia		:= {}
	Local cAliasSBC		:= ""
	Local cNrlote		:= ''
	Local lMTZ61TRV		:= ExistBlock("MTZ61TRV")
	Local lTravaReg		:= .T.
	Local lExecSD3		:= If(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local lWmsNew		:= SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local lMAZ61In		:= (ExistBlock('MAZ61IN'))	//-- Atribui valores nos campos de usuario

	Private cDocumento := SD3->D3_DOC
	Private dAZ61Data  := SD3->D3_EMISSAO
	Private aCols      := {}
	Private aHeader    := {}
	Private nOpcA      := 0

	INCLUI := .F. //Vari?el criada pois quando a fun?o ?acionada por MsExecAuto a mesma n? ?criada
	ALTERA := .F. //Vari?el criada pois quando a fun?o ?acionada por MsExecAuto a mesma n? ?criada


	//??????????
	//?Portaria CAT83   |
	//??????????
	If V240CAT83()
		lCAT83:=.T.
	EndIf

	//-- Verifica se est?na filial correta
	If xFilial("SD3") # SD3->D3_FILIAL
		Help(' ',1,'A000FI')
		lContinua := .F.
	EndIf

	//-- S?Trabalha com Movimenta?es RE4/DE4
	If lContinua .And. !SD3->D3_CF $ 'RE4?E4'
		Help(' ',1,'A260NAO')
		lContinua := .F.
	EndIf

	If lContinua .And. SD3->D3_CF $ 'RE4?E4'
		If SuperGetMV("MV_INTACD",.F.,"0") == "1" .and. USACB0('01')
			CB0->(dbsetorder(4))
			CB0->(Dbseek(xfilial('CB0')+'01'+SD3->D3_LOCAL+SD3->D3_COD))
			While CB0->(!EOF()) .and. CB0->CB0_FILIAL+'01'+CB0->CB0_LOCAL+CB0->CB0_CODPRO = xfilial('CB0')+'01'+SD3->D3_LOCAL+SD3->D3_COD
				If CB0->CB0_NUMSEQ == SD3->D3_NUMSEQ
					Help(' ',1,'A260NAO')
					lContinua := .F.
					Exit
				EndiF
				CB0->(Dbskip())
			Enddo
		EndIf
	EndIf

	If lContinua

		cQuery 	:= "SELECT BC_FILIAL, BC_SEQSD3"
		cQuery 	+= " FROM " + RetSqlName("SBC") + " SBC "
		cQuery 	+= " WHERE BC_FILIAL = '"+xFilial("SD3")+"'"
		cQuery 	+= " AND BC_SEQSD3 = '"+SD3->D3_NUMSEQ+"'"
		cQuery 	+= " AND SBC.D_E_L_E_T_<>'*'"
		cAliasSBC 	:= CriaTrab(,.F.)
		cQuery 	:= ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBC,.T.,.T.)
		If !Empty((cAliasSBC)->BC_SEQSD3) .And. SD3->D3_CHAVE == "E0"
			lContinua := .F.
		Endif

		If !lContinua
			Help(' ',1,'A260NAO')
		EndIf

	Endif

	//????????????????????????????????
	//?Verificar data do ultimo fechamento em SX6.                  ?
	//????????????????????????????????
	If dDataFec >= dDataBase .Or.;
			dDataFec >= SD3->D3_EMISSAO
		Help ( " ", 1, "FECHTO" )
		SetCursor(0)
		lContinua := .F.
	EndIf

	//??????????????????????????
	//?erifica se o usuario tem permissao de exclusao. ?
	//??????????????????????????
	aArea2 := GetArea()
	aAreaSD3 := SD3->(GetArea())
	SD3->(DbSetorder(2))
	SD3->(dbSeek(xFilial("SD3")+cDocumento))
	While !SD3->(Eof()) .And. lContinua .And. SD3->D3_DOC == cDocumento
		lContinua := MaAvalPerm(1,{SD3->D3_COD,"MTA260",5})
		SD3->(dbSkip())
	End
	RestArea(aAreaSD3)
	RestArea(aArea2)
	If !lContinua
		Help(,,1,'SEMPERM')
	EndIf

	//?????????????????????????????????
	//?Verifica calend?io cont?il                ?
	//?????????????????????????????????
	If lContinua
		lContinua := (CtbValiDt(Nil,SD3->D3_EMISSAO,,Nil ,Nil ,{"EST001"}))
	EndIf

	If lContinua
		//????????????????????????????????????
		//?Inicializa variaveis para campos Memos Virtuais                  	 ?
		//????????????????????????????????????
		If Type("aMemos")=="A" .And. Len(aMemos) > 0
			For nMem :=1 To Len(aMemos)
				cMemo := aMemos[nMem][2]
				cDescMemo := aMemos[nMem][3]
				If ExistIni(cMemo)
					&cMemo := InitPad(SX3->X3_RELACAO)
				Else
					&cMemo := ""
				EndIf
			Next nMem
		EndIf
		//-- Campo que pode ser alterado na GetDados
		aAdd(aAlter, 'D3_ESTORNO')

		//????????????????????
		//?Montagem do AHeader (Estorno)        ?
		//????????????????????
		aHeader := {}
		aTam := TamSX3('D3_ESTORNO'); Aadd(aHeader, {STR0022, 'D3_ESTORNO', PesqPict('SD3', 'D3_ESTORNO', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Estornado'
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0006, 'D3_COD'    , PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A261VldCod(1)', USADO, 'C', 'SD3', ''}) // 'Prod.Orig.'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0007, 'D3_DESCRI' , PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Desc.Orig.'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0008, 'D3_UM'     , PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'UM Orig.'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0009, 'D3_LOCAL'  , PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Almox(1)' , USADO, 'C', 'SD3', ''}) // 'Almox Orig.'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0010, 'D3_LOCALIZ', PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Locali(1)', USADO, 'C', 'SD3', ''}) // 'Localiz.Orig.'
		aTam := TamSX3('D3_COD'    ); Aadd(aHeader, {STR0011, 'D3_COD'    , PesqPict('SD3', 'D3_COD'    , aTam[1]         ), aTam[1], aTam[2], 'A261VldCod(2)', USADO, 'C', 'SD3', ''}) // 'Prod.Destino'
		aTam := TamSX3('D3_DESCRI' ); Aadd(aHeader, {STR0012, 'D3_DESCRI' , PesqPict('SD3', 'D3_DESCRI' , aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Desc.Destino'
		aTam := TamSX3('D3_UM'     ); Aadd(aHeader, {STR0013, 'D3_UM'     , PesqPict('SD3', 'D3_UM'     , aTam[1], aTam[1]), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'UM Destino'
		aTam := TamSX3('D3_LOCAL'  ); Aadd(aHeader, {STR0014, 'D3_LOCAL'  , PesqPict('SD3', 'D3_LOCAL'  , aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Almox(2)' , USADO, 'C', 'SD3', ''}) // 'Almox Destino'
		aTam := TamSX3('D3_LOCALIZ'); Aadd(aHeader, {STR0015, 'D3_LOCALIZ', PesqPict('SD3', 'D3_LOCALIZ', aTam[1]         ), aTam[1], aTam[2], 'U_AZ61Locali(2)', USADO, 'C', 'SD3', ''}) // 'Localiz.Destino'
		aTam := TamSX3('D3_NUMSERI'); Aadd(aHeader, {STR0016, 'D3_NUMSERI', PesqPict('SD3', 'D3_NUMSERI', aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'N?ero Serie'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0018, 'D3_LOTECTL', PesqPict('SD3', 'D3_LOTECTL', aTam[1]     )	, aTam[1], aTam[2], 'AZ61Lote(1)'  , USADO, 'C', 'SD3', ''}) // 'Lote'
		aTam := TamSX3('D3_NUMLOTE'); Aadd(aHeader, {STR0017, 'D3_NUMLOTE', PesqPict('SD3', 'D3_NUMLOTE', aTam[1]     )	, aTam[1], aTam[2], 'AZ61Lote(1)'  , USADO, 'C', 'SD3', ''}) // 'Sub-Lote'
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0019, 'D3_DTVALID', PesqPict('SD3', 'D3_DTVALID', aTam[1]     )	, aTam[1], aTam[2], ''             , USADO, 'D', 'SD3', ''}) // 'Validade'
		aTam := TamSX3('D3_POTENCI'); Aadd(aHeader, {STR0039, 'D3_POTENCI', PesqPict('SD3', 'D3_POTENCI', aTam[1]     )	, aTam[1], aTam[2], ''             , USADO, 'N', 'SD3', ''}) // 'Potencia'
		aTam := TamSX3('D3_QUANT'  ); Aadd(aHeader, {STR0020, 'D3_QUANT'  , PesqPict('SD3', 'D3_QUANT'  		            )	, aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Quantidade'
		aTam := TamSX3('D3_QTSEGUM'); Aadd(aHeader, {STR0021, 'D3_QTSEGUM', PesqPict('SD3', 'D3_QTSEGUM'			        )	, aTam[1], aTam[2], 'U_AZ61Quant(.T.)'  , USADO, 'N', 'SD3', ''}) // 'Qt 2aUM'
		aTam := TamSX3('D3_NUMSEQ' ); Aadd(aHeader, {STR0028, 'D3_NUMSEQ' , PesqPict('SD3', 'D3_NUMSEQ' , aTam[1]         )	, aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Sequencia'
		aTam := TamSX3('D3_LOTECTL'); Aadd(aHeader, {STR0044, 'D3_LOTECTL', PesqPict('SD3', 'D3_LOTECTL', aTam[1]     )	, aTam[1], aTam[2], ''   , USADO, 'C', 'SD3', ''})
		aTam := TamSX3('D3_DTVALID'); Aadd(aHeader, {STR0046,'D3_DTVALID'	, PesqPict('SD3', 'D3_DTVALID', aTam[1]    )	, aTam[1], aTam[2], 'AZ61DtPot(3)' , USADO, 'D', 'SD3', ''}) // 'Validade Destino'
		//-- Tratamento dos campos para utilizacao do SIGAWMS
		If	aZ61IntWMS()
			aTam := TamSX3('D3_SERVIC'); Aadd(aHeader, {RetTitle('D3_SERVIC'), 'D3_SERVIC', PesqPict('SD3', 'D3_SERVIC', aTam[1]      ), aTam[1], aTam[2], ''  , USADO, 'C', 'SD3', ''})
			nPosServic := aScan(aheader,{|x| Alltrim(x[2])=="D3_SERVIC"})
		EndIf
		aTam := TamSX3('D3_ITEMGRD' ); Aadd(aHeader, {STR0055, 'D3_ITEMGRD' , PesqPict('SD3', 'D3_ITEMGRD' , aTam[1]      )	, aTam[1], aTam[2], ''             , USADO, 'C', 'SD3', ''}) // 'Sequencia'
		nPosGrade := ascan(aheader,{|x| Alltrim(x[2])=="D3_ITEMGRD"})

		//??????????
		//?Portaria CAT83   |
		//??????????
		If lCAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0065,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // Cod.CAT83
			aTam := TamSX3('D3_CODLAN'); Aadd(aHeader, {STR0066,'D3_CODLAN', PesqPict('SD3','D3_CODLAN', aTam[1]), aTam[1], aTam[2], '' , USADO, 'C', 'SD3', ''}) // Cod.CAT83
			nPosCAT83O  := aScan(aheader,{|x| Alltrim(x[2])=="D3_CODLAN"})
			nPosCAT83D  := IIF(nPosCAT83O>0,nPosCAT83O+1,0)
		EndIf

		//??????????
		//?Percentual FCI   |
		//??????????
		If nFCICalc == 1
			aTam := TamSX3('D3_PERIMP'  ); Aadd(aHeader, {"Per. Imp.", 'D3_PERIMP'  	, PesqPict('SD3', 'D3_PERIMP'), aTam[1], aTam[2], 'A250VlPImp()', USADO, 'N', 'SD3', ''}) // 'Percentual Importacao'
			nPosPerImp  := aScan(aheader,{|x| Alltrim(x[2])=="D3_PERIMP"})    //Percental Importacao
		EndIf

		If Type("aMemos")=="A" .And. Len(aMemos) > 0
			aTam := TamSX3(cMemo);Aadd(aHeader, {cDescMemo, cMemo, PesqPict('SD3', cMemo, aTam[1]         ), aTam[1], aTam[2], ''             , USADO, 'M', 'SD3', ''})	// CAMPOS MEMO
		EndIf
		//-- ExecBlock para incluir campos no aHeader
		If lMAZ61Cpo
			ExecBlock('MAZ61CPO',.F.,.F.)
		EndIf

		ADHeadRec(cAlias,aHeader)

		//-- Posicionamento das Ordens utilizadas na fun?o
		SB1->(dbSetOrder(1))
		SD3->(dbSetOrder(8))

		//????????????????????
		//?Montagem do ACols (Estorno)          ?
		//????????????????????
		aCols   := {}
		aRecnos := {}
		cNumSeq := '?

		If !SD3->(dbSeek( cSeek := xFilial('SD3')+cDocumento,.F.))
			Help(' ',1,'A260NAO')
			lContinua := .F.
		EndIf
	EndIf
	Do While lContinua .And. !SD3->(Eof()) .And. cSeek == SD3->D3_FILIAL+SD3->D3_DOC
		If Empty(SD3->D3_ESTORNO) .And. SD3->D3_CF $ 'RE4?E4'
			aAdd(aCols, Array(Len(aHeader)))
			cNumSeq := SD3->D3_NUMSEQ
		Else
			SD3->(dbSkip())
			Loop
		EndIf
		Do While !SD3->(Eof()) .And. cNumSeq == SD3->D3_NUMSEQ
			If Empty(SD3->D3_ESTORNO) .And. SD3->D3_CF $ 'RE4'
				//??????????????????????????????????????
				//?AvalMovDiv - Funcao utilizada para avaliar possiveis divergencias de     |
				//|              saldo no estorno do movimento selecionado.                  ?
				//??????????????????????????????????????
				If AvalMovDiv(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_NUMSEQ)
					Return
				EndIf
				//-- Posiciona o Arquivo de Produtos (SB1)
				If !SB1->(dbSeek(xFilial('SB1')+SD3->D3_COD,.F.))
					Help(' ', 1, 'REGNOIS')
					lContinua := .F.
					Exit
				EndIf
				cCFAnt := SD3->D3_CF
				Aadd(aRecnos,{ SD3->(Recno()),Len(aCols) })
				aCols[Len(aCols),nPosEstor]     := 'S'
				aCols[Len(aCols),nPosCODOri]    := SD3->D3_COD
				aCols[Len(aCols),nPosDOri]      := SB1->B1_DESC
				aCols[Len(aCols),nPosUMOri]     := SD3->D3_UM
				aCols[Len(aCols),nPosLOCOri]    := SD3->D3_LOCAL
				aCols[Len(aCols),nPosQUANT]     := SD3->D3_QUANT
				aCols[Len(aCols),nPosQTSEG]     := SD3->D3_QTSEGUM
				aCols[Len(aCols),nPosNumSeq]    := cNumSeq
				aCols[Len(aCols),nPosGrade]     := SD3->D3_ITEMGRD
				aCols[Len(aCols),nPosLcZOri]:= SD3->D3_LOCALIZ
				aCols[Len(aCols),nPosNSer]  := SD3->D3_NUMSERI
				aCols[Len(aCols),nPosLoTCTL]:= SD3->D3_LOTECTL
				aCols[Len(aCols),nPosNLOTE] := SD3->D3_NUMLOTE
				aCols[Len(aCols),nPosDTVAL] := SD3->D3_DTVALID
				aCols[Len(aCols),nPosPotenc]:= SD3->D3_POTENCI
				If	nPosServic > 0
					aCols[Len(aCols),nPosServic] := SD3->D3_SERVIC
				EndIf

				If nPosCAT83O>0
					aCols[Len(aCols),nPosCAT83O]:= SD3->D3_CODLAN
				EndIf

				//?????????????????????????????????????
				//?Tratamento para Dead-Lock                                              ?
				//?????????????????????????????????????
				If aScan(aLockSD3,SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)==0
					Aadd(aLockSD3,SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)
				EndIf
				If aScan(aLockSB2,SD3->D3_COD+SD3->D3_LOCAL)==0
					aadd(aLockSB2,SD3->D3_COD+SD3->D3_LOCAL)
				EndIf
			ElseIf Empty(SD3->D3_ESTORNO) .And. SD3->D3_CF $ 'DE4'
				//-- Posiciona o Arquivo de Produtos (SB1)
				If !SB1->(dbSeek(xFilial('SB1')+SD3->D3_COD,.F.))
					Help(' ', 1, 'REGNOIS')
					lContinua := .F.
					Exit
				EndIf
				//-- Verifica se o saldo do armz esta bloqueado
				If !SldBlqSB2(SD3->D3_COD,SD3->D3_LOCAL)
					lContinua := .F.
					Exit
				EndIf
				Aadd(aRecnos,{ SD3->(Recno()),Len(aCols) })
				aCols[Len(aCols),nPosCODDes]		:= SD3->D3_COD
				aCols[Len(aCols),nPosDDes]			:= SB1->B1_DESC
				aCols[Len(aCols),nPosUMDes]			:= SD3->D3_UM
				aCols[Len(aCols),nPosLOCDes]		:= SD3->D3_LOCAL
				aCols[Len(aCols),nPosLcZDes]	:= SD3->D3_LOCALIZ
				aCols[Len(aCols),nPosLotDes]	:= SD3->D3_LOTECTL
				aCols[Len(aCols),nPosDtVldD]	:= SD3->D3_DTVALID
				If	nPosServic > 0
					aCols[Len(aCols),nPosServic] := SD3->D3_SERVIC
				EndIf

				If nPosCAT83D>0
					aCols[Len(aCols),nPosCAT83D]:= SD3->D3_CODLAN
				EndIf
				If nFCICalc == 1
					aCols[Len(aCols),nPosPerImp]:= SD3->D3_PERIMP
				EndIf
				If Rastro(SD3->D3_COD,'S')
					cNumLotRE4 := SD3->D3_NUMLOTE
				Else
					cNumLotRE4 := Nil
				EndIf
				//?????????????????????????????????????
				//?Tratamento para Dead-Lock                                              ?
				//?????????????????????????????????????
				If aScan(aLockSD3,SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)==0
					Aadd(aLockSD3,SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)
				EndIf
				If aScan(aLockSB2,SD3->D3_COD+SD3->D3_LOCAL)==0
					aadd(aLockSB2,SD3->D3_COD+SD3->D3_LOCAL)
				EndIf
			EndIf

			//??????????????????????????????
			//?Verificando Data de origem do lote                      ?
			//??????????????????????????????


			aCols[Len(aCols)][Len(aHeader)-1] := "SD3"
			aCols[Len(aCols)][Len(aHeader)]	  := SD3->(RecNo())

			SD3->(dbSkip())
			If !Empty(aCols[Len(aCols),nPosCODOri]) .And. !Empty(aCols[Len(aCols),nPosCODDes])
				Exit
			EndIf
		EndDo
		If !lContinua
			Exit
		EndIf
		If Empty(aCols[Len(aCols),nPosCODOri]) .Or. Empty(aCols[Len(aCols),nPosCODDes])
			Help(' ',1,'A260NAO')
			lContinua := .F.
			Exit
		EndIf
		//??????????????????????????????
		//?Validacao WMS.                                          ?
		//??????????????????????????????
		If	lContinua .And. aZ61IntWMS(aCols[Len(aCols),nPosCODDes])
			If !lWmsNew
				//-- Validar Servico WMS de transferencia quando informado.
				If	nPosServic > 0 .And. !Empty(cServico := aCols[Len(aCols),nPosServic])
					//A ordem de servi? WMS ?gerada para o local destino
					If WmsChkDCF('SD3',,,cServico,'3',,cDocumento,,,,aCols[Len(aCols),nPosLOCDes],aCols[Len(aCols),nPosCODDes],,,cNumSeq)
						lContinua := WmsAvalDCF('2')
					EndIf
				EndIf
				If lContinua .And. (SuperGetMV('MV_WMSVLDT',.F.,.T.)==.T.)
					//No estorno o destino deve ser assumido como a origem
					If !WmsVldDest(aCols[Len(aCols),nPosCODOri],aCols[Len(aCols),nPosLOCOri],aCols[Len(aCols),nPosLcZOri],aCols[Len(aCols),nPosLoTCTL],aCols[Len(aCols),nPosNLOTE],aCols[Len(aCols),nPosNSer],aCols[Len(aCols),nPosQUANT])
						lContinua := .F.
					EndIf
				EndIf
			ElseIf !lExecSD3
				// Valida?o [NOVO WMS]
				oOrdSerDel := WMSDTCOrdemServicoDelete():New()
				oOrdSerDel:SetIdDCF(SD3->D3_IDDCF)
				If oOrdSerDel:LoadData()
					If !oOrdSerDel:CanDelete()
						Help( ,1,"SIGAWMS",,oOrdSerDel:GetErro(),1,0)
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf
		//-- ExecBlock para atribuir valores nos campos de usuario
		If lMAZ61In
			ExecBlock('MAZ61IN',.F.,.F.)
		EndIf
	EndDo

	If lContinua .And. Len(aCols) == 0
		Help(' ',1,'A240ESTORN')
		lContinua := .F.
	EndIf

	If lContinua
		SD3->(dbSetOrder(2))

		//????????????????????????????
		//?Verifica se algum produto est?sendo inventariado.  ?
		//????????????????????????????
		For nX := 1 to Len(aCols)
			If BlqInvent(aCols[nX,nPosCODOri],aCols[nX,nPosUMOri],,aCols[nX,nPosLcZOri])
				Help(' ',1,'BLQINVENT',,aCols[nX,nPosCODOri]+STR0054+aCols[nX,nPosUMOri],1,11) //' Almox: '
				lContinua := .F.
				Exit
			EndIf
			If lContinua .And. BlqInvent(aCols[nX,nPosCODDes],aCols[nX,nPosLOCDes],,aCols[nX,nPosLcZDes])
				Help(' ',1,'BLQINVENT',,aCols[nX,nPosCODDes]+STR0054+aCols[nX,nPosLOCDes],1,11) //' Almox: '
				lContinua := .F.
				Exit
			EndIf
			//????????????????????????????
			//?Analisa se o tipo do armazem permite a movimentacao |
			//????????????????????????????
			If lContinua .And. AvalBlqLoc(aCols[nX,nPosCODOri],aCols[nX,nPosLOCOri],Nil,,aCols[nX,nPosCODDes],aCols[nX,nPosLOCDes])
				lContinua := .F.
				Exit
			EndIf
			//????????????????????????????
			//?Verifica se o produto destino tem saldo p/ estornar ?
			//????????????????????????????
			SD3->(Dbgoto(aCols[nx,len(acols[nx])]))         //posiciona no SD3 em foco para pegar o numlote correto.
			cNrlote:=SD3->D3_NUMLOTE
			If !MatVldEst(aCols[nx,nPosCODDes],;
					aCols[nx,nPosLOCDes],;
					aCols[nx,nPosLoTDes],;
					cNrlote,;
					If(Empty(cServico),aCols[nx,nPosLcZDes],""),;
					aCols[nx,nPosNSer],;
					aCols[nx,nPosNumSeq],;
					cDocumento,;
					aCols[nx,nPosQUANT])
				lContinua := .F.
				Exit
			EndIf
		Next nX
	EndIf

	If lContinua
		If ! lAutoma261
			//????????????????????????????????
			//?Calcula dimens?s                                            ?
			//????????????????????????????????
			oSize := FwDefSize():New()

			oSize:AddObject( "CIMA"  ,  100,  5, .T., .T.) // Nao dimensiona Y
			oSize:AddObject( "BAIXO",  100, 95, .T., .T.) // Totalmente dimensionavel

			oSize:lProp := .T. // Proporcional
			oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize:Process() // Dispara os calculos

			nOpcX := 5
			nOpcA := 0
			//????????????????????????????????
			//?Executa ponto de entrada para montar array com botoes a      ?
			//?serem apresentados na tela                                   ?
			//????????????????????????????????
			If (ExistBlock("MZ61BCHOI"))
				aButZ61:=ExecBlock("MZ61BCHOI",.F.,.F.)
				If ValType(aButZ61) # "A"
					aButZ61:={}
				EndIf
			EndIf
			//????????????????????????????????
			//?Monta Dialog                                                 ?
			//????????????????????????????????
			DEFINE MSDIALOG oDlg TITLE cCadastro ;  //"Transferencia Mod2"
				FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL
			//????????????????????????????????
			//?Adiciona Panel                                               ?
			//????????????????????????????????
			oPanel1:= tPanel():New(oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI"),,oDlg,,,,,,oSize:GetDimension("CIMA","XSIZE"),oSize:GetDimension("CIMA","YSIZE"),,)
			oPanel2:= tPanel():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),,oDlg,,,,,,oSize:GetDimension("BAIXO","XSIZE"),oSize:GetDimension("BAIXO","YSIZE"),,)

			@ 0,0 SAY   OemToAnsi("Numero da OP") OF oPanel1 PIXEL // 'N?ero Documento'
			@ 0,50 MSGET cDocumento When .F. SIZE 70,08 OF oPanel1 PIXEL
			@ 0,125 SAY   OemToAnsi(STR0024) OF oPanel1 PIXEL // 'Emiss?'
			@ 0,150 MSGET dAZ61Data When .F. SIZE 40,08 OF oPanel1 PIXEL

			//????????????????????????????????
			//?onto de Entrada que disponibiliza o Objeto da Dialog        ?
			//????????????????????????????????
			If (ExistBlock( "MTZ61CAB" ))
				ExecBlock("MTZ61CAB",.F.,.F.,{@oPanel1,oSize:aPosObj[1,1],nOpcx})
			EndIf

			oGet := MSGetDados():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),oSize:GetDimension("BAIXO","LINEND"),oSize:GetDimension("BAIXO","COLEND"),;
				nOpcX,'AllwaysTrue','AllwaysTrue','',;
				,aAlter,NIL,NIL,;
				LINHAS,,,,,,,,,oPanel2)


			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End(),If(oGet:TudoOK(),nOpcA:=2,nOpcA := 0)},{||oDlg:End()},,aButZ61)
		Else
			nOpcA := 2
		EndIf
		For nX := 1 to Len(aCols)
			SD3->(Dbgoto(aCols[nx,len(acols[nx])]))   //posiciona no SD3 em foco para pegar o numlote correto.
			cNrlote:=SD3->D3_NUMLOTE
			lVldEst := MatVldEst(aCols[nx,nPosCODDes],aCols[nx,nPosLOCDes],aCols[nx,nPosLoTDes],cNrlote,If(Empty(cServico),aCols[nx,nPosLcZDes],""),aCols[nx,nPosNSer],aCols[nx,nPosNumSeq],cDocumento,aCols[nx,nPosQUANT])
			If !lVldEst
				Exit
			EndIf
		Next

		If nOpcA == 2 .And. lVldEst
			aDelSD7 := {}
			If AZ61EstrOK(cDocumento,@aDelSD7)
				//?????????????????????????????????????
				//?Tratamento para Dead-Lock                                              ?
				//?????????????????????????????????????
				If lMTZ61TRV
					lTravaReg := ExecBlock("MTZ61TRV",.F.,.F.,{aLockSB2,aLockSD3})
					If ValType(lTravaReg) # "L"
						lTravaReg := .T.
					EndIf
				EndIf
				If If(lTravaReg, MultLock("SB2",aLockSB2,1) .And. MultLock("SD3",aLockSD3,3), .T.)


					For nX := 1 to Len(aRecnos)
						If aCols[aRecnos[nX,2],nPosEstor] == 'S'
							dbSelectArea('SD3')
							SD3->(dbGoTo(aRecnos[nX,1]))
							aSD3Area[3] := SD3->(Recno())

							//-- Verifica se algum produto utiliza CQ Celerina
							lEstQualy := .F.
							For nY := 1 to Len(aCols)
								If SB1->(dbSeek(xFilial('SB1') + aCols[nY, nPosCODDes], .F.)) .And. ;
										RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == 'Q' .And. aCols[nY, nPosLOCDes] == cLocCQ
									lEstQualy := .T.
									Exit
								EndIf
							Next nY

							Begin Transaction
								RecLock('SD3',.F.)
								AZ61DesAtu()
								SD3->(MsUnlock())
							End Transaction

						EndIf
					Next nX
					nDelSD7 := 0
					For nX := 1 to Len(aDelSD7)
						SD7->(dbGoto(aDelSD7[nX]))

						lEstQualy := (SB1->(dbSeek(xFilial('SB1')+SD7->D7_PRODUTO, .F.)) .And.;
							(RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"))

						If lEstQualy

							//????????????????????????????????
							//?Exclus? do CQ no SigaQIE                                    ?
							//????????????????????????????????

							//????????????????????????????????
							//?osiciona o registro no SD5 para que o LOTECTL+NUMLOTE seja en?
							//?iado para qAtuMatQie()										 ?
							//????????????????????????????????
							If Rastro(SD7->D7_PRODUTO,"L") .Or. Rastro(SD7->D7_PRODUTO,"S")
								aAreaSD5 := SD5->(GetArea())
								SD5->(dbSetOrder(3))
								If SD5->(dbSeek(xFilial('SD5')+SD7->D7_NUMSEQ+SD7->D7_PRODUTO+SD7->D7_LOCAL+SD7->D7_LOTECTL, .F.))
									cLotCtlQie := SD5->D5_LOTECTL
									cNumLotQie := SD5->D5_NUMLOTE
								EndIf
								SD5->(dbSetOrder(aAreaSD5[2]))
								SD5->(dbGoto(aAreaSD5[3]))
							EndIf

							aEnvCele := {SD7->D7_DOC			,; //Numero da Nota Fiscal
								SD7->D7_SERIE					,; //Serie da Nota Fiscal
								"N"								,; //Tipo da Nota Fiscal
								SD7->D7_DATA					,; //Data de Emissao da Nota Fiscal
								SD7->D7_DATA					,; //Data de Entrada da Nota Fiscal
								"NF"							,; //Tipo de Documento
								Space(TamSX3("D1_ITEM")[1])		,; //Item da Nota Fiscal
								Space(TamSX3("D1_REMITO")[1])	,; //Numero do Remito (Localizacoes)
								Space(TamSX3("D1_PEDIDO")[1])	,; //Numero do Pedido de Compra
								Space(TamSX3("D1_ITEMPC")[1])	,; //Item do Pedido de Compra
								SD7->D7_FORNECE					,; //Codigo Fornecedor/Cliente
								SD7->D7_LOJA					,; //Loja Fornecedor/Cliente
								SD7->D7_LOTECTL					,; //Numero do Lote do Fornecedor
								Space(TamSX3("QEK_SOLIC")[1])	,; //Codigo do Solicitante
								SD7->D7_PRODUTO					,; //Codigo do Produto
								SD7->D7_LOCAL					,; //Local Origem
								cLotCtlQie						,; //Numero do Lote
								cNumLotQie						,; //Sequencia do Sub-Lote
								SD7->D7_NUMSEQ					,; //Numero Sequencial
								SD7->D7_NUMERO					,; //Numero do CQ
								SD7->D7_SALDO					,; //Quantidade
								0								,; //Preco
								0								,; //Dias de atraso
								" "								,; //TES
								AllTrim(FunName())				,; //Origem
								" "								,; //Origem TXT
								PadR(0,15)}				           //Tamanho do lote original

							//????????????????????????????????
							//?Realiza a exclusao do material enviado para Inspecao	     ?
							//????????????????????????????????
							aRecCele := qAtuMatQie(aEnvCele,2)

						EndIf

						SD7->(dbGoto(aDelSD7[nX]))
						RecLock('SD7', .F.)
						dbDelete()
						MsUnlock()
						nDelSD7 ++
					Next nX
				Else
					ConOut("WARNING: DEADLOCK CONTROL IS ON")
				EndIf
				If nDelSD7 > 0
					SD7->(WriteSX2('SD7', nDelSD7))
				EndIf
			EndIf
		EndIf

		If cCusMed == 'O' .And. nTotal <> 0
			If !lCriaHeade
				//????????????????????????????????
				//?Se ele criou o arquivo de prova ele deve gravar o rodape'    ?
				//????????????????????????????????
				//?????????????????????????????????
				//?mv_par01 - Se mostra e permite digitar lancamentos contabeis   ?
				//?mv_par02 - Se deve aglutinar os lancamentos contabeis          ?
				//?????????????????????????????????
				n := 1
				RodaProva(nHdlPrv,nTotal)
				If !Empty(aCtbDia)
					cCodDiario := CtbaVerdia()
					For nX := 1 to Len(aCtbDia)
						aCtbDia[nX][3] := cCodDiario
					Next nX
				EndIf
				cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
				lCriaHeade := .T.
			EndIf
		EndIf
	EndIf
	If nOpca == 0 .And. (ExistBlock("MTAZ61CAN"))
		//????????????????????????????????
		//?xecuta P.E. ao sair sem gravar 				                 ?
		//????????????????????????????????
		ExecBlock("MTAZ61CAN",.F.,.F.,{nOpcx})
	EndIf
	//-- Retorna a integridade do Sistema
	RestArea(aSB1Area)
	RestArea(aSD3Area)
	RestArea(aSD7Area)
	RestArea(aArea)

Return nOpcA

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??                                                                      ??
??                                                                      ??
??                  ROTINAS DE CRITICA DE CAMPOS                        ??
??                                                                      ??
??                                                                      ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61TudOk ?Autor ?Marcelo Pimentel      ?Data ?0/01/98  ??
???????????????????????????????????????
??escri?o ?Critica se a Transferencia est?Ok.                        ??
???????????????????????????????????????
??intaxe   ?AZ61TudOK(ExpO1,ExpN1) 		                              ??
???????????????????????????????????????
??arametros?ExpO1 = Objeto a ser verificado.                           ??
??         ?ExpN1 = numero do registro			                      ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MataZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function aZ61TudoOk(o,nLinha)
	Static lPontoEntr := NIL
	Local lRet        := .T.
	Local nX		  := 0
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri	:= 1 	//Codigo do Produto Origem
	Local nPosLOCOri	:= 4	//Armazem Origem
	Local nPosLcZOri	:= 5	//Localizacao Origem
	Local nPosCODDes	:= 6	//Codigo do Produto Destino
	Local nPosLOCDes	:= 9	//Armazem Destino
	Local nPosLcZDes	:= 10	//Localizacao Destino
	Local nPosNSer	:= 11	//Numero de Serie
	Local nPosLoTCTL	:= 12	//Lote de Controle
	Local nPosNLOTE	:= 13	//Numero do Lote
	Local nPosQUANT	:= 16	//Quantidade
	Local nPosCTLDes	:= 20	//Lote de Controle Destino
	Default nLinha 	:= n

	//????????????????????????????????
	//?Verifica se existe ponto de entrada para validacao           ?
	//????????????????????????????????
	If (lPontoEntr == NIL)
		lPontoEntr := ExistBlock("AZ61TOK")
	EndIf

	If !aCols[nLinha,Len(aCols[nLinha])]
		If Empty(aCols[nLinha,nPosCODOri]) .Or. Empty(aCols[nLinha,nPosLOCOri]) .Or. ;
				Empty(aCols[nLinha,nPosCODDes]) .Or. Empty(aCols[nLinha,nPosLOCDes])
			Help(' ',1,'MA260OBR')
			lRet := .F.
		EndIf
		If lRet
			For nX := 1 To Len(aCols)
				/*
				If nX # nLinha .And. !aCols[nx,Len(aCols[nx])] .And. aCols[nLinha,nPosCODOri]+aCols[nLinha,nPosLOCOri]+aCols[nLinha,nPosCODDes]+aCols[nLinha,nPosLOCDes]+aCols[nLinha,nPosNSer]+aCols[nLinha,nPosNLOTE]+aCols[nLinha,nPosLoTCTL]+aCols[nLinha,nPosLcZOri]+aCols[nLinha,nPosLcZDes]+aCols[nLinha,nPosCTLDes] == aCols[nX,nPosCODOri]+aCols[nX,nPosLOCOri]+aCols[nX,nPosCODDes]+aCols[nX,nPosLOCDes]+aCols[nX,nPosNSer]+aCols[nX,nPosNLOTE]+aCols[nX,nPosLoTCTL]+aCols[nX,nPosLcZOri]+aCols[nX,nPosLcZDes]+aCols[nX,nPosCTLDes]
					Help(' ',1,'A242JACAD')
					lRet := .F.
				EndIf
				*/
				//????????????????????????????
				//?Validacao do Saldo em Estoque                     |
				//????????????????????????????
				nQuant := aCols[nLinha,nPosQUANT]
				If nQuant > 0
					__cAlias := GetArea()
					nTotlocal := nQuant
					dbSelectArea("SB2")
					msSeek(xFilial()+aCols[nLinha,nPosCODOri]+aCols[nLinha,nPosLOCOri])
					//nTotLocal := SaldoSB2()
					nTotLocal := SB2->B2_QATU
					If nTotLocal < nQuant
						FWAlertError("Saldo insuficiente: "+str(nTotLocal,10,2),"Produto "+aCols[nLinha,nPosCODOri])
						lRet := .F.
					Endif
					RestArea(__cAlias)
				Endif
				//????????????????????????????
				//?Validacao do Custo FIFO On-Line                     |
				//????????????????????????????
				If IsFifoOnLine()
					If SaldoSBD("SD3",aCols[nLinha,nPosCODOri],aCols[nLinha,nPosLOCOri],dDataBase,.F.)[1] < aCols[nLinha,nPosQUANT]
						Help(" ",1,"DIVFIFO2")
						lRet := .F.
					EndIf
				EndIf
			Next nX
		EndIf
	EndIf

	//????????????????????????????????
	//?Executa ponto de entrada para validacao                      ?
	//????????????????????????????????
	If lRet .And. lPontoEntr
		lRet := ExecBlock("AZ61TOK",.F.,.F.)
		lRet := If(ValType(lRet)#"L",.T.,lRet)
	EndIf

	//?????????????????????????????????
	//?Verifica calend?io cont?il                ?
	//?????????????????????????????????
	If lRet
		lRet := (CtbValiDt(Nil,DAZ61DATA,,Nil ,Nil ,{"EST001"}))
	EndIf

Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Grava ?Autor ?Marcelo Pimentel      ?Data ?5/02/98  ??
???????????????????????????????????????
??escri?o ?Gravar os dados no arquivo                                 ??
???????????????????????????????????????
??intaxe   ?AZ61Grava(ExpC1,ExpN1)		                              ??
???????????????????????????????????????
??arametros?ExpC1 = Alias do arquivo                                   ??
??         ?ExpN1 = Numero da opcao selecionada                        ??
??         ?ExpL1 = Valida se o no. do documento sera alterado         ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??so       ?MataZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function aZ61Grava(cAlias,nOpcao,lChangeDoc,aRecSD3,aAutoItens)
	Static lMA260NFQ := NIL

	Local aArea      := GetArea()
	Local aSD3Area   := SD3->(GetArea())
	Local aSD3Area   := SD4->(GetArea())
	Local aSD7Area   := SD7->(GetArea())
	Local aSX6Area   := SX6->(GetArea())
	Local aAreaSD5   := SD5->(GetArea())
	Local aCTBEnt	   := CTBEntArr()
	Local nMaxArray  := 0
	Local cNumSeq    := ''
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	Local lRet       := .T.
	Local lQualyCQ   := .F.
	Local nAtraso    := 0
	Local aMov       := {}
	Local aEnvCele   := {}
	Local aRecCele   := {}
	Local cForNFO    := ''
	Local cLojNFO    := ''
	Local cPedNFO    := ''
	Local cDocNFO    := ''
	Local cSerNFO    := ''
	Local cTipNFO    := ''
	Local cIPCNFO    := ''
	Local cMay       := ''
	Local nX		:= 0
	Local nY		:= 0
	Local nW		:= 0

	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri 	:= 1 	//Codigo do Produto Origem
	Local nPosDOri		:= 2	//Descricao do Produto Origem
	Local nPosUMOri		:= 3	//Unidade de Medida Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6	//Codigo do Produto Destino
	Local nPosUMDes		:= 8	//Unidade de Medida Destino
	Local nPosLOCDes 	:= 9	//Armazem Destino
	Local nPosLcZDes 	:= 10	//Localizacao Destino
	Local nPosNSer		:= 11	//Numero de Serie
	Local nPosLoTCTL	:= 12	//Lote de Controle
	Local nPosNLOTE		:= 13	//Numero do Lote
	Local nPosDTVAL		:= 14	//Data Valida
	Local nPosPotenc 	:= 15	//Potencia do Lote
	Local nPosQUANT		:= 16	//Quantidade
	Local nPosQTSEG		:= 17	//Quantidade na 2a. Unidade de Medida
	Local nPosDtVldD 	:= 21	//Data Valida de Destino
	Local nPosServic 	:= aScan(aheader,{|x| Alltrim(x[2])=="D3_SERVIC"})
	Local nPosCAT83O	:= aScan(aheader,{|x| Alltrim(x[2])=="D3_CODLAN"})    //Cod.CAT 83 Prod.Origem
	Local nPosCAT83D	:= IIF(nPosCAT83O>0,nPosCAT83O+1,0)					 //Cod.CAT 83 Prod.Destino
	Local nPosPerImp	:= aScan(aheader,{|x| Alltrim(x[2])=="D3_PERIMP"})    //Percental Importacao
	Local nPosIDDCF		:= aScan(aheader,{|x| Alltrim(x[2])=="D3_IDDCF"})
	Local nPosNumSeq	:= Iif(!__lPyme,19,16)	//Sequencia
	Local nQtdOri		:= 0
	Local nPos			:= 0
	Local cItemNF		:= " "
	Local cDocEnt		:= ''
	Local dNotFis		:= cTOD('')
	Local nPreco		:= 0
	Local lQtdRep		:= If(GetMV("MV_QTRFREP")=="S",.T.,.F.)  // variavel desnecessaria para integra?o QIExEST
	Local cCodEIC		:= SubStr(GetMv('MV_PRODIMP'),1,Len(SB1->B1_COD))
	Local cLotCtlQie	:= ''
	Local cNumLotQie	:= ''
	Local cServico		:= ''
	Local cNumDesp		:= ''
	Local cLoteFor		:= ''
	Local nLoop 		:= 0
	Local aLockSB2		:= {}
	Local aItenSD3		:= {{}}
	Local cMemo
	Local cDescMemo
	Local nMem
	Local nPItem		:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_ITEMGRD"})
	Local nExistGrade	:= 0
	Local lFirstNum		:= .T.
	Local lCAT83		:= .F.
	Local lMtNLote 		:= If(SuperGetMV("MV_MTNLOTE",,"N")=="S",.T.,.F.)
	Local lMantemLot	:= .F.
	Local lMAZ61TRD3 	:= ExistBlock("MAZ61TRD3")
	Local lMTZ61TRV		:= ExistBlock("MTZ61TRV")
	Local lTravaReg		:= .T.
	Local lExecSD3		:= If(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local lWmsNew		:= SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local lValLote		:= .T.
	Local cDocWMS		:= ""
	Local lMT260NLOT	:= ExistBlock('MT260NLOT')	//-- Op?o para o tipo de SubLote

	If Type('N')=='U'
		Private N := 0
	EndIf

	DEFAULT lChangeDoc := .F.
	DEFAULT aRecSD3    := {}

	//??????????
	//?Portaria CAT83   |
	//??????????
	If V240CAT83()
		lCAT83:=.T.
	EndIf

	lMA260NFQ := If(lMA260NFQ==NIL,ExistBlock("MA260NFQ"),lMA260NFQ)
	//????????????????????????????????
	//?Verifica se o ultimo elemento do array esta em branco        ?
	//????????????????????????????????
	nMaxArray := Len(aCols)
	For nY := 1 to Len(aHeader)
		If Empty(aCols[nMaxArray, nY])
			If Upper(AllTrim(aHeader[nY,2])) == 'D3_QUANT'
				nMaxArray--
				Exit
			EndIf
		EndIf
	Next nY
	//????????????????????????????????????
	//?Inicializa variaveis para campos Memos Virtuais         			 ?
	//????????????????????????????????????
	If Type("aMemos")=="A" .And. Len(aMemos) > 0
		For nMem :=1 To Len(aMemos)
			cMemo := aMemos[nMem][2]
			If ExistIni(cMemo)
				&cMemo := InitPad(SX3->X3_RELACAO)
			Else
				&cMemo := ""
			EndIf
		Next nMem
	EndIf

	//-- Verificar integracao com rotina automatica
	If lAutoma261 .And. lWmsNew .And. lExecSD3
		cDocumento := Iif(!Empty(aAutoItens[1,1]),aAutoItens[1,1],cDocumento)
	Else
		//????????????????????????????????
		//?Verifica se durante a digitacao n? foi incluido um documento?
		//?com o mesmo numero por outro usu?io.                        ?
		//????????????????????????????????
		dbSelectArea('SD3')
		dbSetOrder(2)
		dbSeek(xFilial()+cDocumento)
		cMay := "SD3"+Alltrim(xFilial())+cDocumento
		lFirstNum := .T.
		While D3_FILIAL+D3_DOC==xFilial()+cDocumento.Or.!MayIUseCode(cMay)
			If D3_ESTORNO # "S"
				If lFirstNum
					cDocumento := NextNumero("SD3",2,"D3_DOC",.T.)
					cDocumento := AZ61RetINV(cDocumento)
					lFirstNum := .F.
				Else
					cDocumento := Soma1(cDocumento)
				EndIf
				lChangeDoc := .T.
				cMay := "SD3"+Alltrim(xFilial())+cDocumento
			EndIf
			dbSkip()
		EndDo

		If lWmsNew
			dbSelectArea("DH1")
			DH1->(dbSetOrder(2))
			If DH1->(dbSeek(xFilial("DH1")+cDocumento))
				cDocWms	:= NextNumero("DH1",2,"DH1_DOC",.T.)
				cDocumento := cDocWms
				cMay := "SD3"+Alltrim(xFilial())+cDocumento
			EndIf
		EndIf

	EndIf

	//Utilizado na mensagem unica
	If Type('cDocIntMU') <> "U"
		cDocIntMU	:= cDocumento
	Endif
	RestArea(aSD3Area)

	//?????????????????????????????????????
	//?Tratamento para Dead-Lock                                              ?
	//?????????????????????????????????????
	For nX:=1 to Len(aCols)
		If aScan(aLockSB2,aCols[nX][nPosCODOri]+aCols[nX][nPosLOCOri])==0
			aadd(aLockSB2,aCols[nX][nPosCODOri]+aCols[nX][nPosLOCOri]) //Produto+Local
		EndIf
		If aScan(aLockSB2,aCols[nX][nPosCODDes]+aCols[nX][nPosLOCDes])==0
			aadd(aLockSB2,aCols[nX][nPosCODDes]+aCols[nX][nPosLOCDes]) //Produto+Local
		EndIf
	Next nX
	//?????????????????????????????????????
	//?Tratamento para Dead-Lock                                              ?
	//?????????????????????????????????????
	If MultLock("SB2",aLockSB2,1)
		For nLoop := 1 to nMaxArray
			n := nLoop
			SB5->(dbSetOrder(1))
			SB5->(dbSeek(xFilial("SB5")+aCols[n,nPosCODOri]))

			//-- Posiciona (ou Cria) o Arquivo de Saldos (SB2)
			If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri],.F.))
				CriaSB2(aCols[n,nPosCODOri],aCols[n,nPosLOCOri])
			EndIf
			//-- Posiciona (ou Cria) o Arquivo de Saldos (SB2)
			If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODDes]+aCols[n,nPosLOCDes],.F.))
				CriaSB2(aCols[n,nPosCODDes],aCols[n,nPosLOCDes])
			EndIf

			If !lWmsNew
				lValLote := .T.
			Else
				If IntWMS(aCols[n,nPosCODOri])
					lValLote := .F.
					lMantemLot := .T.
				EndIf
			EndIf

			//?????????????????????????????
			//?Ponto de Entrada para escolher o tipo de sub-lote     ?
			//?????????????????????????????
			If lValLote
				If lMT260NLOT
					lMantemLot := ExecBlock("MT260NLOT",.F.,.F.,{aCols[n,nPosCODOri],aCols[n,nPosCODDes],aCols[n,nPosLoTCTL],aCols[n,nPosLotDes]})
					If ValType(lMtNLote) <> "L"
						lMantemLot := .F.
					EndIf
				ElseIf lMtNLote
					//??????????????????????????????????????????
					//?Transferencia entre produtos ou lotes diferentes necess?io alterar o sub-lote  ?
					//??????????????????????????????????????????
					If (aCols[n,nPosLoTCTL]!= aCols[n,nPosLotDes] .And. !Empty(aCols[n,nPosLotDes])) .Or. aCols[n,nPosCODOri] != aCols[n,nPosCODDes]
					lMantemLot := .F.
				Else
					lMantemLot := .T.
				EndIf
			EndIf
		EndIf

		If aZ61IntWMS(aCols[n,nPosCODOri]) .And. lWmsNew .And. !lExecSD3
			//-- Posiciona no Arquivo de Produtos (SB1)
			If !SB1->(dbSeek(xFilial('SB1')+aCols[n,nPosCODOri],.F.))
				Help(' ',1,'NOFOUNDSB1')
				Loop
			EndIf


			//???????????????????????????
			//?Pega o proximo numero sequencial de movimento      ?
			//???????????????????????????
			cNumSeq := ProxNum()

			//Utilizado na mensagem unica
			If Type('cNSeqIntMU') <> "U"
				cNSeqIntMU := cNumSeq
			Endif

			For nW:= 1 To 2
				// Gerar a movimentacao de REQUISICAO = 1 / DEVOLUCAO = 2
				AADD(aItenSD3[Len(aItenSD3)],xFilial('SD3'))																			//-- D3_FILIAL
				AADD(aItenSD3[Len(aItenSD3)],IIf(nW = 1,"999","499") )																//-- D3_TM
				AADD(aItenSD3[Len(aItenSD3)],dAZ61Data)																				//-- D3_EMISSAO
				AADD(aItenSD3[Len(aItenSD3)],cNumSeq)																					//-- D3_NUMSEQ
				AADD(aItenSD3[Len(aItenSD3)],IIf(nW = 1,aCols[n,nPosCODOri],aCols[n,nPosCODDes]))								//-- D3_COD
				If	nW == 1
					AADD(aItenSD3[Len(aItenSD3)],If(Rastro(aCols[n,nPosCODOri]),aCols[n,nPosLoTCTL],CriaVar('D3_LOTECTL')))	//-- D3_LOTECTL
				Else
					cLoteDes:=If(Empty(aCols[n,nPosLotDes]),aCols[n,nPosLoTCTL],aCols[n,nPosLotDes])
					AADD(aItenSD3[Len(aItenSD3)],If(Rastro(aCols[n,nPosCODDes]),cLoteDes,CriaVar('D3_LOTECTL')))
				EndIf
				AADD(aItenSD3[Len(aItenSD3)],IIf(nW = 1,aCols[n,nPosLOCOri],aCols[n,nPosLOCDes]))								//-- D3_LOCAL
				AADD(aItenSD3[Len(aItenSD3)],IIf(nW = 1,aCols[n,nPosLcZOri],aCols[n,nPosLcZDes]))								//-- D3_LOCALIZ
				AADD(aItenSD3[Len(aItenSD3)],aCols[n,nPosQUANT])																		//-- D3_Quant
				AADD(aItenSD3[Len(aItenSD3)],ConvUm(aCols[n,nPosCODOri],aCols[n,nPosQUANT],aCols[n,nPosQTSEG],2))				//-- D3_QTSEGUM
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_TRT
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_PROJPMS
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_TASKPMS
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_CLVL
				aAdd(aItenSD3[Len(aItenSD3)],aCols[n,nPosServic])																	//-- D3_SERVIC
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_CC
				AADD(aItenSD3[Len(aItenSD3)],SB1->B1_CONTA)																			//-- D3_CONTA
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_ITEMCTA
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_STATUS
				AADD(aItenSD3[Len(aItenSD3)],"")																						//-- D3_OP
				If SD3->(FieldPos("D3_NUMSA")) > 0
					AADD(aItenSD3[Len(aItenSD3)],"")																					//-- D3_NUMSA
				Else
					AADD(aItenSD3[Len(aItenSD3)],""	)																					//-- D3_NUMSA
				EndIf
				If SD3->(FieldPos("D3_ITEMSA")) > 0
					AADD(aItenSD3[Len(aItenSD3)],"")																					//-- D3_ITEMSA
				Else
					AADD(aItenSD3[Len(aItenSD3)],""	)																					//-- D3_ITEMSA
				EndIf
				AADD(aItenSD3[Len(aItenSD3)],cDocumento)																				//-- D3_DOC
				AADD(aItenSD3[Len(aItenSD3)],IIf(nW = 1,"RE4","DE4"))																//-- D3_CF
				If nW == 1
					AADD(aItenSD3[Len(aItenSD3)],If(Rastro(aCols[n,nPosCODOri],'S'),aCols[n,nPosNLOTE],CriaVar('D3_NUMLOTE')))	//-- D3_NUMLOTE
				Else
					AADD(aItenSD3[Len(aItenSD3)],If(lMantemLot,aCols[n,nPosNLOTE],CriaVar("D3_NUMLOTE")))							//-- D3_NUMLOTE
				EndIf

				AADD(aItenSD3[Len(aItenSD3)],aCols[n,nPosNSer])																		//-- D3_NUMSERI

				// Funcao que grava a DH1 gera servico WMS e efetua a movimentacoao de lote
				EspDH1Wms(aItenSD3,"MATAZ61",,IIF(nW = 1,"2","1"),@oOrdServ)
				ADEL(aItenSD3[1],1)
				ASIZE(aItenSD3[1],1)
				aItenSD3[1] := {}
			Next nW
		Else
			If !aCols[n][Len(aCols[n])] //--  verifica se nao esta deletado (DEL)
				___cAlias  := GetArea()
				nLocDes := 9
				nPosReg := 24
				dbSelectArea("SD4")
				dbGoto(aCols[n,nPosReg])
				RecLock('SD4',.F.)
				SD4->D4_LOCAL := aCols[n,nLocDes]
				MsUnlock()
				RestArea(___cAlias)
			Endif
			If !aCols[n][Len(aCols[n])] .And. U_AZ61Quant(.F.) //--  verifica se nao esta deletado (DEL)
				If lMAZ61TRD3
					AADD(aRecSD3,{})
				EndIf
				cNumSeq := IIf(!lExecSD3,ProxNum(),aCols[n,nPosNumSeq]) //-- Pega o proximo numero sequencial de movimento

				//Utilizado na mensagem unica
				If Type('cNSeqIntMU') <> "U"
					cNSeqIntMU := cNumSeq
				Endif
				//????????????????????????????
				//?Gera as Movimenta?es no SD3.                        ?
				//????????????????????????????

				//-- Verifica se o Produto Destino vai para o CQ Celerina
				cForNFO := ''
				cLojNFO := ''
				cPedNFO := ''
				cDocNFO := ''
				cSerNFO := ''
				cTipNFO := ''
				cIPCNFO := ''
				nQtdOri := 0
				cItemNF := ''
				cDocEnt := ''
				dNotFis := cTOD('')
				nPreco  := 0
				If (lQualyCQ:=SB1->(dbSeek(xFilial('SB1')+aCols[n,nPosCODDes], .F.)) .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=='Q'.And.aCols[n,nPosLOCDes]==cLocCQ.And.cLocCQ#aCols[n,nPosLOCOri])
				//?????????????????????????????????????
				//?Verifica se a existencia do P.E. MA260NFQ, para que nao seja exibida   ?
				//?a tela para selecao de materiais a serem transferidos para o CQ, quan- ?
				//?do houver integracao com o Quality.									   ?
				//?????????????????????????????????????
				If lMA260NFQ
					lQualyCQ := Execblock("MA260NFQ",.F.,.F.)
					lQualyCQ := If(ValType(lQualyCQ)#"L",.T.,lQualyCQ)
				Else
					If !a260NFOrig(aCols[n,nPosCODOri],aCols[n,nPosLOCOri],aCols[n,nPosLoTCTL],aCols[n,nPosNLOTE],.T.,aCols[n,nPosLocDes])
						If Aviso(STR0029,STR0033 + AllTrim(aCols[n,nPosCODOri]) + STR0034,{STR0035,STR0036}) == 1 // 'Siga Quality'###'Envia o Produto '###' somente para CQ Materiais?'###'Sim'###'Aborta'
							lQualyCQ := .F.
						Else
							lRet	:= .F.
							Exit
						EndIf
					EndIf
				EndIf

				If lQualyCQ
					If Alias() == 'SWN'
						cForNFO := SWN->WN_FORNECE
						cLojNFO := SWN->WN_LOJA
						cDocNFO := SWN->WN_DOC
						cSerNFO := SWN->WN_SERIE
						cTipNFO := SWN->WN_TIPO_NF
						nQtdOri := SWN->WN_QUANT
						cItemNF := StrZero(Val(SWN->WN_ITEM),2)
						nPreco  := SWN->WN_VALOR

						SD1->(dbSetOrder(1))
						If SD1->(dbSeek(xFilial('SD1')+cDocNFO+cSerNFO+cForNFO+cLojNFO+cCodEIC))
							cPedNFO := SD1->D1_PEDIDO
							cIPCNFO := SD1->D1_ITEMPC
							cDocEnt := SD1->D1_LOTEFOR
							dNotFis := SD1->D1_EMISSAO
						EndIf
					Else
						cForNFO := SD1->D1_FORNECE
						cLojNFO := SD1->D1_LOJA
						cPedNFO := SD1->D1_PEDIDO
						cDocNFO := SD1->D1_DOC
						cSerNFO := SD1->D1_SERIE
						cTipNFO := SD1->D1_TIPO
						cIPCNFO := SD1->D1_ITEMPC
						nQtdOri := SD1->D1_QUANT
						cItemNF := SD1->D1_ITEM
						cDocEnt := SD1->D1_LOTEFOR
						dNotFis := SD1->D1_EMISSAO
						nPreco  := SD1->D1_VUNIT
					EndIf
				EndIf
			EndIf
			//-- Posiciona no Arquivo de Produtos (SB1)
			If !SB1->(dbSeek(xFilial('SB1')+aCols[n,nPosCODOri],.F.))
				Help(' ',1,'NOFOUNDSB1')
				Loop
			EndIf

			//-- Posiciona (ou Cria) o Arquivo de Saldos (SB2)
			If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri],.F.))
				CriaSB2(aCols[n,nPosCODOri],aCols[n,nPosLOCOri])
			EndIf

			RecLock('SD3', .T.) //-- Origem
			SD3->D3_FILIAL  := xFilial('SD3')
			SD3->D3_COD     := aCols[n,nPosCODOri]
			SD3->D3_QUANT   := aCols[n,nPosQUANT]
			SD3->D3_CF      := 'RE4'
			SD3->D3_CHAVE   := 'E0'
			SD3->D3_LOCAL   := aCols[n,nPosLOCOri]
			SD3->D3_DOC     := cDocumento
			SD3->D3_EMISSAO := dAZ61Data
			SD3->D3_UM      := aCols[n,nPosUMOri]
			SD3->D3_GRUPO   := SB1->B1_GRUPO
			SD3->D3_NUMSEQ  := cNumSeq
			SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,aCols[n,nPosQUANT],aCols[n,nPosQTSEG],2)
			SD3->D3_SEGUM   := SB1->B1_SEGUM
			SD3->D3_TM      := '999'
			SD3->D3_TIPO    := SB1->B1_TIPO
			SD3->D3_CONTA   := SB1->B1_CONTA
			For nX := 1 To Len(aCTBEnt)
				SD3->&("D3_EC"+aCTBEnt[nX]+"CR") := SB1->&("B1_EC"+aCTBEnt[nX]+"CR")
				SD3->&("D3_EC"+aCTBEnt[nX]+"DB") := SB1->&("B1_EC"+aCTBEnt[nX]+"DB")
			Next nX
			SD3->D3_USUARIO := CUSERNAME
			SD3->D3_LOTECTL := If(Rastro(aCols[n,nPosCODOri]),aCols[n,nPosLoTCTL],CriaVar('D3_LOTECTL'))
			SD3->D3_NUMLOTE := If(Rastro(aCols[n,nPosCODOri],'S'),aCols[n,nPosNLOTE],CriaVar('D3_NUMLOTE'))
			SD3->D3_DTVALID := If(Rastro(aCols[n,nPosCODOri]),aCols[n,nPosDTVAL],CriaVar('D3_DTVALID'))
			SD3->D3_POTENCI := If(Rastro(aCols[n,nPosCODOri]),aCols[n,nPosPotenc],CriaVar('D3_POTENCI'))
			SD3->D3_LOCALIZ := aCols[n,nPosLcZOri]
			SD3->D3_NUMSERI := aCols[n,nPosNSer]

			If Type("cNumSeqP3") == "C" .And. cNumSeqP3 <> Nil
				SD3->D3_IDENT := cNumSeqP3
			EndIf

			//??????????
			//?Portaria CAT83   |
			//??????????
			If lCAT83 .And. nPosCAT83O>0 .And. aCols[n,nPosCODOri] != aCols[n,nPosCODDes]
				Replace D3_CODLAN With If(Empty(aCols[n,nPosCAT83O]),A240CAT83(),aCols[n,nPosCAT83O])
			EndIf
			If lAutoma261 .And. nPosIDDCF > 0
				SD3->D3_IDDCF:= aCols[n,nPosIDDCF]
			EndIf
			IF Ascan(AHEADER,{ |x| x[2] == 'D3_OBSERVA'}) > 0
				SD3->D3_OBSERVA := aCols[n,Ascan(AHEADER,{ |x| x[2] == 'D3_OBSERVA'})]
			Endif
			MsUnlock()

			If lMAZ61TRD3
				AADD(aRecSD3[Len(aRecSD3)],SD3->(Recno()))
			EndIf

			//???????????????????????????????????
			//?rava os campos Memos Virtuais					 				  ?
			//???????????????????????????????????
			If Type("aMemos") == "A"   .And. Len(aMemos) > 0
				For nMem := 1 to Len(aMemos)
					cVar := aMemos[nMem][2]
					MSMM(,TamSx3(aMemos[nMem][2])[1],,&cVar,1,,,"SD3",aMemos[nMem][1])
				Next nMem
			EndIf
			aAdd(aRegSD3,SD3->(Recno()))

			//???????????????????????
			//?Pega os 15 custos medios atuais            ?
			//???????????????????????
			aCM := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)
			//???????????????????????
			//?Grava o custo da movimentacao              ?
			//???????????????????????
			aCusto := GravaCusD3(aCM)

			//???????????????????????
			//?Grava Lote do Fornecedor e Num. Despacho   ?
			//???????????????????????
			dbSelectArea('SB8')
			dbSetOrder(3)
			If SB8->(dbSeek(xFilial('SB8')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri]+aCols[n,nPosLoTCTL],.F.))
				cLoteFor:= SB8->B8_LOTEFOR
				cNumDesp:= SB8->B8_NUMDESP
			EndIf

			//?????????????????????????????
			//?Atualiza o saldo atual (VATU) com os dados do SD3     ?
			//?????????????????????????????
			If !B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,cLoteFor,cNumDesp)
				//?????????????????????????????
				//?Ponto de entrada para gravar no mov. de Origem         ?
				//?????????????????????????????

				If lMZ61D3O
					ExecBlock('MZ61D3O',.F.,.F.,n)
				EndIf
				//-- Verifica se o custo medio ?calculado On-Line e, se necessario, cria o
				//-- cabecalho do arquivo de Prova
				If cCusMed == 'O' .And. lCriaHeade
					lCriaHeade := .F.
					nHdlPrv := HeadProva(cLoteEst,'MATAZ61',Subs(cUsuario,7,6),@cArquivo)
				EndIf

				//?????????????????????????????
				//?Verifica se o custo medio e' calculado On-Line        ?
				//?????????????????????????????
				If cCusMed == 'O'
					//??????????????????????????
					//?Gera o lancamento no arquivo de prova           ?
					//??????????????????????????
					nTotal += DetProva(nHdlPrv,'670','MATAZ61',cLoteEst)
					If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
						aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
					Else
						aCtbDia := {}
					EndIF
				EndIf

				//-- Posiciona no Arquivo de Produtos (SB1)
				If aCols[n,nPosCODOri] # aCols[n,nPosCODDes] .And. ;
						!SB1->(dbSeek(xFilial('SB1')+aCols[n,nPosCODDes],.F.))
					Help(' ',1,'NOFOUNDSB1')
					Loop
				EndIf

				RecLock('SD3',.T.) //-- Destino
				SD3->D3_FILIAL  := xFilial('SD3')
				SD3->D3_COD     := aCols[n,nPosCODDes]
				SD3->D3_QUANT   := aCols[n,nPosQUANT]
				SD3->D3_CF      := 'DE4'
				SD3->D3_CHAVE   := 'E9'
				SD3->D3_LOCAL   := aCols[n,nPosLOCDes]
				SD3->D3_DOC     := cDocumento
				SD3->D3_EMISSAO := dAZ61Data
				SD3->D3_UM      := aCols[n,nPosUMDes]
				SD3->D3_GRUPO   := SB1->B1_GRUPO
				SD3->D3_NUMSEQ  := cNumSeq
				SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,aCols[n,nPosQUANT],aCols[n,nPosQTSEG],2)
				SD3->D3_SEGUM   := SB1->B1_SEGUM
				SD3->D3_TM      := '499'
				SD3->D3_TIPO    := SB1->B1_TIPO
				SD3->D3_CONTA   := SB1->B1_CONTA
				For nX := 1 To Len(aCTBEnt)
					SD3->&("D3_EC"+aCTBEnt[nX]+"CR") := SB1->&("B1_EC"+aCTBEnt[nX]+"CR")
					SD3->&("D3_EC"+aCTBEnt[nX]+"DB") := SB1->&("B1_EC"+aCTBEnt[nX]+"DB")
				Next nX
				SD3->D3_USUARIO := CUSERNAME
				cLoteDes:=If(Empty(aCols[n,nPosLotDes]),aCols[n,nPosLoTCTL],aCols[n,nPosLotDes])
				SD3->D3_LOTECTL := If(Rastro(aCols[n,nPosCODDes]),cLoteDes,CriaVar('D3_LOTECTL'))
				SD3->D3_NUMLOTE := If(lMantemLot,aCols[n,nPosNLOTE],CriaVar("D3_NUMLOTE"))
				SD3->D3_DTVALID := If(Rastro(aCols[n,nPosCODDes]),aCols[n,nPosDtVldD],CriaVar('D3_DTVALID'))
				SD3->D3_POTENCI := If(Rastro(aCols[n,nPosCODDes]),aCols[n,nPosPotenc],CriaVar('D3_POTENCI'))
				SD3->D3_LOCALIZ := aCols[n,nPosLcZDes]
				SD3->D3_NUMSERI := aCols[n,nPosNSer]

				If Type("cNumSeqP3") == "C" .And. cNumSeqP3 <> Nil
					SD3->D3_IDENT := cNumSeqP3
				EndIf
				If lAutoma261 .And. nPosIDDCF > 0
					SD3->D3_IDDCF:= aCols[n,nPosIDDCF]
				EndIf
				//-- Usado somente para SIGAWMS
				If nPosServic > 0 .And. !Empty(cServico := aCols[n,nPosServic])
					SD3->D3_SERVIC := cServico
				EndIf

				//??????????
				//?Portaria CAT83   |
				//??????????
				If lCAT83 .And. nPosCAT83D>0 .And. aCols[n,nPosCODOri] != aCols[n,nPosCODDes]
					Replace D3_CODLAN With If(Empty(aCols[n,nPosCAT83D]),A240CAT83(),aCols[n,nPosCAT83D])
				EndIf

				//??????????
				//?Percentual FCI   |
				//??????????
				If nFCICalc == 1
					Replace D3_PERIMP With aCols[n,nPosPerImp]
				EndIf

				if Ascan(AHEADER,{ |x| x[2] == 'D3_OBSERVA'}) > 0
					SD3->D3_OBSERVA := aCols[n,Ascan(AHEADER,{ |x| x[2] == 'D3_OBSERVA'})]
				Endif
				MsUnlock()

				If lMAZ61TRD3
					AADD(aRecSD3[Len(aRecSD3)],SD3->(Recno()))
				EndIf

				aAdd(aRegSD3,SD3->(Recno()))

				//???????????????????????
				//?Grava o custo da movimentacao              ?
				//???????????????????????
				aCusto := GravaCusD3(aCM)

				//?????????????????????????????
				//?Atualiza o saldo atual (VATU) com os dados do SD3     ?
				//?????????????????????????????
				B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.,NIL,NIL,cServico,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,cLoteFor,cNumDesp)

				/* Atualiza sublote na etiquta(CB0), tratamento especifico do template ACD */
				If (usacb0("01") .and. IsTelnet())
					If Rastro(SD3->D3_COD,"S")
						For ny := 1 to len(aHisEti)
							aEtiq := CBRetEti(aHisEti[ny],"01")
							RecLock("CB0",.f.)
							If Localiza(aEtiq[1]) // Transf. entre enderecos
								If aLista[n][6] == aEtiq[17]
									CB0->CB0_SLOTE := SD3->D3_NUMLOTE
								EndIf
							Else
								If aLista[n][5] == aEtiq[17]// Transf. entre Armazens
									CB0->CB0_SLOTE :=SD3->D3_NUMLOTE
								EndIf
							EndIf
							MsUnlock()
						Next
					EndIf
				EndIf

				//-- Inclui o Produto Destino no CQ
				If AllTrim(cLocCQ) == AllTrim(aCols[n,nPosLOCDes]) .And. AllTrim(cLocCQ) # AllTrim(aCols[n,nPosLOCOri])
					fGeraCQ0('SD3', SD3->D3_COD, 'TR', aCols[n,nPosLOCOri])
					//?????????????????????????????
					//?Atualiza o CQ do modulo SigaQuality                   ?
					//?????????????????????????????
					If lQualyCQ
						SB1->(dbSetOrder(1))
						lQualyCQ := SB1->(dbSeek(xFilial("SB1")+SD3->D3_COD)) .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q"
					EndIf

					If lQualyCQ

						nAtraso    := 0
						nSC7OrdAnt := SC7->(IndexOrd())
						nSC7RecAnt := SC7->(Recno())
						SC7->(dbSetOrder(1))
						If SC7->(dbSeek(xFilial('SC7')+cPedNFO+cIPCNFO, .F.))
							nAtraso := SD3->D3_DTVALID-SC7->C7_DATPRF
						EndIf

						SC7->(dbSetOrder(nSC7OrdAnt))
						SC7->(dbGoto(nSC7RecAnt))
						//????????????????????????????????
						//?osiciona o Registro do SD5, para envio do LOTECTL+NUMLOTE a  ?
						//?qAtuMatQie().												 ?
						//????????????????????????????????
						cLotCtlQie := ''
						cNumLotQie := ''
						If Rastro(SD3->D3_COD,"L") .Or. Rastro(SD3->D3_COD,"S")
							aAreaSD5 := SD5->(GetArea())
							SD5->(dbSetOrder(3))
							If SD5->(dbSeek(xFilial('SD5')+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL,.F.))
								cLotCtlQie := SD5->D5_LOTECTL
								cNumLotQie := SD5->D5_NUMLOTE
							EndIf
							SD5->(dbSetOrder(aAreaSD5[2]))
							SD5->(dbGoto(aAreaSD5[3]))
						EndIf

						//????????????????????????????????
						//?Passa LOTECTL+NUMLOTE p/ser gravado nos campos de Lote do QIE?
						//????????????????????????????????
						nSC7OrdAnt := SC7->(IndexOrd())
						nSC7RecAnt := SC7->(Recno())
						SC7->(dbSetOrder(1))
						If SC7->(dbSeek(xFilial('SC7')+cPedNFO+cIPCNFO, .F.))
							nAtraso := SD3->D3_DTVALID-SC7->C7_DATPRF
						Else
							nAtraso := 0
						EndIf

						SC7->(dbSetOrder(nSC7OrdAnt))
						SC7->(dbGoto(nSC7RecAnt))
						//????????????????????????????????
						//?Grava os dados referentes ao Inspecao de Entradas (SIGAQIE)  ?
						//????????????????????????????????

						//Grava a quantidade original do item rejeitado
						If !lQtdRep
							cItemNF := ''
							cDocEnt := SD3->D3_DOC
							dNotFis := SD3->D3_EMISSAO
							nPreco  := SD3->D3_CUSTO1
						EndIf

						aEnvCele := {cDocNFO				,; //Numero da Nota Fiscal
							cSerNFO							,; //Serie da Nota Fiscal
							cTipNFO 						,; //Tipo da Nota Fiscal
							dNotFis							,; //Data de Emissao da Nota Fiscal
							SD3->D3_EMISSAO					,; //Data de Entrada da Nota Fiscal
							"TR"							,; //Tipo de Documento
							cItemNF							,; //Item da Nota Fiscal
							Space(TamSX3("D1_REMITO")[1])	,; //Numero do Remito (Localizacoes)
							cPedNFO							,; //Numero do Pedido de Compra
							Space(TamSX3("D1_ITEMPC")[1])	,; //Item do Pedido de Compra
							cForNFO							,; //Codigo Fornecedor/Cliente
							cLojNFO							,; //Loja Fornecedor/Cliente
							cDocEnt							,; //Numero do Lote do Fornecedor
							Space(6)						,; //Codigo do Solicitante
							SD3->D3_COD						,; //Codigo do Produto
							SD3->D3_LOCAL					,; //Local Origem
							cLotCtlQie						,; //Numero do Lote
							cNumLotQie						,; //Sequencia do Sub-Lote
							SD3->D3_NUMSEQ					,; //Numero Sequencial
							SD7->D7_NUMERO					,; //Numero do CQ
							SD3->D3_QUANT					,; //Quantidade
							nPreco							,; //Preco
							nAtraso							,; //Dias de atraso
							" "								,; //TES
							AllTrim(FunName())				,; //Origem
							" "								,; //Origem TXT
							PadR(nQtdOri,15)}				   //Tamanho do lote original

						//????????????????????????????????
						//?Realiza a integracao Materiais x Inspecao de Entradas		 ?
						//????????????????????????????????
						aRecCele := qAtuMatQie(aEnvCele,1)

						//????????????????????????????????
						//?Libera?o Automatica (FREE-PASS) - Parametrizada no SigaQIE  ?
						//????????????????????????????????
						If aRecCele[1] == 'C' .or. aRecCele[1] =='L'
							//-- Liberar totalmente a movimenta?o no SD7 com Free-Pass
							aMov := {}
							aAdd(aMov, {})
							aAdd(aMov[Len(aMov)], 1)
							aAdd(aMov[Len(aMov)], SD7->D7_SALDO)
							aAdd(aMov[Len(aMov)], SD7->D7_LOCDEST)
							aAdd(aMov[Len(aMov)], SD7->D7_DATA)
							aAdd(aMov[Len(aMov)], '')
							aAdd(aMov[Len(aMov)], '')
							aAdd(aMov[Len(aMov)], aRecCele[2])
							aAdd(aMov[Len(aMov)], SD7->D7_QTSEGUM)
							fGravaCQ(SD7->D7_PRODUTO, SD7->D7_NUMERO, .F., aMov, PegaCMD3())
						EndIf

					EndIf
				EndIf


				//????????????????????????????????
				//?ExecBlock apos gravacao do SD3                               ?
				//????????????????????????????????
				If lMAZ61D3
					ExecBlock('MAZ61D3',.F.,.F.,n)
				EndIf

				//????????????????????????????????
				//?Verifica se o custo medio e' calculado On-Line               ?
				//????????????????????????????????
				If cCusMed == 'O'
					//??????????????????????????
					//?Gera o lancamento no arquivo de prova           ?
					//??????????????????????????
					nTotal += DetProva(nHdlPrv,'672','MATAZ61',cLoteEst)
				EndIf
			EndIf
		Else
			//????????????????????????????????
			//?Cria array com os movimentos dos Produtos sem saldos         ?
			//????????????????????????????????
			If lLogMov
				LogSaldo(aCols[n,nPosCODOri],aCols[n,nPosDOri],aCols[n,nPosUMOri],aCols[n,nPosLOCOri],aCols[n,nPosQUANT],;
					aCols[n,nPosLoTCTL],aCols[n,nPosNLOTE],aCols[n,nPosDTVAL],aCols[n,nPosLcZOri],aCols[n,nPosNSer],;
					@aLogSld,cDocumento,dAZ61Data)
			EndIf
		EndIf
	EndIf
	Next n
	If lRet .And. cCusMed == 'O' .And. nTotal <> 0
		If !lCriaHeade
			//????????????????????????????????
			//?Se ele criou o arquivo de prova ele deve gravar o rodape'    ?
			//????????????????????????????????
			//?????????????????????????????????
			//?mv_par01 - Se mostra e permite digitar lancamentos contabeis   ?
			//?mv_par02 - Se deve aglutinar os lancamentos contabeis          ?
			//?????????????????????????????????
			n := 1
			RodaProva(nHdlPrv,nTotal)
			If !Empty(aCtbDia)
				cCodDiario := CtbaVerdia()
				For nX := 1 to Len(aCtbDia)
					aCtbDia[nX][3] := cCodDiario
				Next nX
			EndIf
			If cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
				lCriaHeade := .T.
				//???????????????????????????????
				//?Grava a data de Contabilizacao do campo D3_DTLANC         ?
				//???????????????????????????????
				For nX := 1 To Len(aRegSD3)
					SD3->(dbGoTo(aRegSD3[nX]))
					RecLock("SD3",.F.)
					Replace D3_DTLANC With dDataBase
					MsUnLock()
				Next nX
			EndIf
		EndIf
	EndIf
	Else
	ConOut("WARNING: DEADLOCK CONTROL IS ON")
	EndIf

	FreeUsedCode(.T.)

	//??????????????????????????
	//?Ponto de Entrada apos a gravacao da transferencia?
	//??????????????????????????
	If ExistBlock("MTZ61TDOK")
		ExecBlock("MTZ61TDOK",.F.,.F.)
	EndIf

	//-- Restaura a Integridade do Sistema
	RestArea(aSD3Area)
	RestArea(aSD7Area)
	RestArea(aSX6Area)
	RestArea(aArea)
Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61LinOk ?Autor ?Marcelo Pimentel      ?Data ?30/01/98 ??
???????????????????????????????????????
??escri?o ?Programa que faz consistencias apos a digitacao da tela    ??
???????????????????????????????????????
??intaxe   ?AZ61LinOk(ExpO1,ExpN1)		                              ??
???????????????????????????????????????
??arametros?ExpO1 = Objeto a ser verificado.                           ??
??         ?ExpN1 = numero do registro			                      ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
User Function AZ61LinOk(o,nLinha)
	Local aArea      := GetArea()
	Local aSB8Area   := SB8->(GetArea())
	Local lRet       := .T.
	Local aAreaSBE   := { 'SBE', SBE->(IndexOrd()),SBE->(Recno()) }
	Local nX		 := 0
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri 	:= 1	//Codigo do Produto Origem
	Local nPosUmOrig 	:= 3	//Unidade de Medida Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6	//Codigo do Produto Destino
	Local nPosLOCDes 	:= 9	//Armazem Destino
	Local nPosUmDest 	:= 8 	//Unidade de Medida Destino
	Local nPosLcZDes 	:= 10	//Localizacao Destino
	Local nPosNSer		:= 11	//Numero de Serie
	Local nPosLoTCTL 	:= 12	//Lote de Controle
	Local nPosNLOTE		:= 13  	//Numero do Lote
	Local nPosQUANT  	:= 16	//Quantidade
	Local nPosCTLDes 	:= 20  	//Lote de Controle Destino
	Local nPosDLtOri	:= 14	//Data de Validade Origem
	Local nPosDLtDes	:= 21	//Data de Validade Destino
	Local nPosServic    := aScan(aheader,{|x| Alltrim(x[2])=="D3_SERVIC"})
	Local cCodOrig      := ""
	Local cCodDest      := ""
	Local cLocOrig      := ""
	Local cLocDest      := ""
	Local cLoclzOrig    := ""
	Local cLoclzDest    := ""
	Local cNumSerie     := ""
	Local cLoteDigi     := ""
	Local cNumLote      := ""
	Local cServico      := ""
	Local cEstDest      := ""
	Local nQuantZ61     := 0
	Local cProdRef      := " "
	Local cLocCQ        := GetMvNNR('MV_CQ','98')
	Local cOriNSer      := ""
	Local dSB8Emis      := cTOD('')
	Local lWmsSD3       := If(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local lWmsNew	    := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local oSaldoWMS     := Iif(lWmsNew,WMSDTCEstoqueEndereco():New(),Nil)
	Local oMovimento    := Nil

	Static lFnWMSValT

	Default nLinha   := n

	If lFnWMSValT == NIL
		lFnWMSValT := FindFunction('WMSValTPOD')
	EndIf

	If aCols[n][Len(aCols[n])] //--  verifica se esta deletado (DEL)
		RestArea(aArea)
		Return lRet
	Endif

	If !aCols[nLinha,Len(aCols[nLinha])]
		cProdRef:= aCols[nLinha,nPosCODOri]
		If Empty(aCols[nLinha,nPosCODOri]) .Or. Empty(aCols[nLinha,nPosLOCOri]) .Or. ;
				Empty(aCols[nLinha,nPosCODDes]) .Or. Empty(aCols[nLinha,nPosLOCDes])
			Help(' ',1,'MA260OBR')
			lRet := .F.
		EndIf

		//??????????????????
		//?Verifica a permissao do armazem. ?
		//??????????????????
		If lRet
			lRet := MaAvalPerm(3,{aCols[nLinha][nPosLocOri],aCols[n][nPosCodOri]}) .And. MaAvalPerm(3,{aCols[nLinha][nPosLocDes],aCols[n][nPosCodDes]})
		EndIf
		//????????????????????????????
		//?Verifica o local de origem e destino informados     ?
		//????????????????????????????
		If lRet .And. (!U_AZ61Almox(1,aCols[nLinha,nPosLOCOri]) .Or. !U_AZ61Almox(2,aCols[nLinha,nPosLOCDes]))
			lRet := .F.
		EndIf

		//????????????????????????????
		//?Verifica se o produto est?sendo inventariado.      ?
		//????????????????????????????
		If lRet
			If BlqInvent(aCols[nLinha,nPosCODOri],aCols[nLinha,nPosLOCOri],,aCols[nLinha,nPosLcZOri])
				Help(' ',1,'BLQINVENT',,aCols[nLinha,nPosCODOri]+STR0054+aCols[nLinha,nPosLOCOri],1,11) //' Almox: '
				lRet:=.F.
			EndIf
			If BlqInvent(aCols[nLinha,nPosCODDes],aCols[nLinha,nPosLOCDes],,aCols[nLinha,nPosLcZDes])
				Help(' ',1,'BLQINVENT',,aCols[nLinha,nPosCODDes]+STR0054+aCols[nLinha,nPosLOCDes],1,11) //' Almox: '
				lRet:=.F.
			EndIf
			//????????????????????????????
			//?Analisa se o tipo do armazem permite a movimentacao |
			//????????????????????????????
			If lRet .And. AvalBlqLoc(aCols[nLinha,nPosCODOri],aCols[nLinha,nPosLOCOri],Nil,,aCols[nLinha,nPosCODDes],aCols[nLinha,nPosLOCDes])
				lRet := .F.
			EndIf
		EndIf

		//????????????????????????????
		//?Verifica se os Produtos tem saldo bloqueado         ?
		//????????????????????????????
		If lRet //Origem
			lRet := SldBlqSB2(aCols[nLInha,nPosCODOri],aCols[nLinha,nPosLOCOri])
		EndIf
		If lRet //Destino
			lRet := SldBlqSB2(aCols[nLInha,nPosCODDes],aCols[nLinha,nPosLOCDes])
		EndIf

		//????????????????????????????
		//?Validacao do Saldo em Estoque                     |
		//????????????????????????????
		nQuant := aCols[nLinha,nPosQUANT]
		If nQuant > 0
			__cAlias := GetArea()
			nTotlocal := nQuant
			dbSelectArea("SB2")
			msSeek(xFilial()+aCols[nLinha,nPosCODOri]+aCols[nLinha,nPosLOCOri])
			//nTotLocal := SaldoSB2()
			nTotLocal := SB2->B2_QATU
			If nTotLocal < nQuant
				FWAlertError("Saldo insuficiente: "+str(nTotLocal,10,2),"Produto "+aCols[nLinha,nPosCODOri])
				lRet := .F.
			Endif
			RestArea(__cAlias)
		Endif


		//????????????????????????????
		//?Verifica se os Produtos possuem Localizacao         ?
		//????????????????????????????
		If lRet .And. Localiza(aCols[nLinha,nPosCODOri],.T.)
			If ValType(aCols[nLinha,nPosNSer]) == "U"
				cOriNSer := aCols[nLinha,nPosLcZOri]
			Else
				cOriNSer := aCols[nLinha,nPosLcZOri]+aCols[nLinha,nPosNSer]
			EndIf

			If  Empty(cOriNSer)
				Help(' ',1,'MA260OBR')
				lRet := .F.
			EndIf
			If ( cLocCQ == aCols[nLinha,nPosLOCDes] .And. Localiza(aCols[nLinha,nPosCODDes],.T.) .And. ( Empty(aCols[nLinha,nPosLcZDes]) .Or. Empty(aCols[nLinha,nPosLcZDes]+aCols[nLinha,nPosNSer] ) ) )
				Help(' ',1,'MA260OBR')
				lRet := .F.
			EndIf
			If !(lWmsNew .And. aZ61IntWMS(aCols[nLinha,nPosCODOri]))
				If QtdComp(SaldoSBF(aCols[nLinha,nPosLOCOri],aCols[nLinha,nPosLcZOri],aCols[nLinha,nPosCODOri],aCols[nLinha,nPosNSer],aCols[nLinha,nPosLoTCTL],aCols[nLinha,nPosNLOTE])) < QtdComp(aCols[nLinha,nPosQUANT])
					Help(" ",1,"SALDOLOCLZ")
					lRet:=.F.
				EndIf
			Else
				If !lWmsSD3 .And. QtdComp(oSaldoWMS:GetSldWMS(aCols[nLinha,nPosCODOri],aCols[nLinha,nPosLOCOri],aCols[nLinha,nPosLcZOri],aCols[nLinha,nPosLoTCTL],aCols[nLinha,nPosNLOTE],aCols[nLinha,nPosNSer])) < QtdComp(aCols[nLinha,nPosQUANT])
					Help(' ', 1, 'SALDOLOCLZ')
					lRet := .F.
				EndIf
			EndIf
			If lRet .And. !aZ61IntWMS(aCols[nLinha,nPosCODOri])
				dbSelectArea('SBE')
				aAreaSBE := GetArea()
				dbSetOrder(1)
				If dbSeek(xFilial('SBE')+aCols[nLinha,nPosLOCDes]+aCols[nLinha,nPosLcZDes], .F.)
					If SBE->(!Eof()) .And. SBE->BE_CAPACID > 0 .And. QtdComp(aCols[nLinha,nPosQUANT]+QuantSBF(aCols[nLinha,nPosLOCDes],aCols[nLinha,nPosLcZDes],aCols[nLinha,nPosCODDes])) > QtdComp(SBE->BE_CAPACID)
						Help(' ',1,'MA265CAPAC')
						lRet:=.F.
					EndIf
				EndIf
				dbSetOrder(aAreaSBE[2])
				dbGoto(aAreaSBE[3])
			EndIf
		EndIf
		//????????????????????????????
		//?Verifica se o produto possui Rastro.                ?
		//????????????????????????????
		If lRet .And. (Rastro(aCols[nLinha,nPosCODOri]) .And. Empty(aCols[nLinha,nPosLoTCTL]) .Or. ;
				Rastro(aCols[nLinha,nPosCODOri],'S') .And. Empty(aCols[nLinha,nPosNLOTE]))
			Help(' ',1,'MA260LOTE')
			lRet := .F.
		Else
			If ( lRet )
				dbSelectArea( 'SB8' )
				//Validacao Data de Validade Origem
				SB8->( dbSetOrder( 3 ) ) //"B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)"
				If SB8->( dbSeek( FWxFilial( 'SB8' ) + Padr( aCols[ nLinha ][ nPosCODOri ], TamSx3( 'B8_PRODUTO' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosLOCOri ], TamSx3( 'B8_LOCAL' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosLoTCTL ], TamSx3( 'B8_LOTECTL' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosNLOTE  ], TamSx3( 'B8_NUMLOTE' )[ 1 ] ) ) )
					Do Case
						Case ( Empty( SB8->B8_DTVALID ) )
							lRet := .T.
						Case !( Empty( SB8->B8_DTVALID ) ) .And. ( Empty( aCols[ nLinha ][ nPosDLtOri ] ) )
							aCols[ nLinha ][ nPosDLtOri ] := SB8->B8_DTVALID
							lRet := .T.
						Case !( Empty( SB8->B8_DTVALID ) ) .And. !( Empty( aCols[ nLinha ][ nPosDLtOri ] ) )
							If !( SB8->B8_DTVALID == aCols[ nLinha ][ nPosDLtOri ] )
								Help(" ",1,"A240DTVALI")
								lRet := .F.
							EndIf
					EndCase
				EndIf

				If ( lRet )
					//Validacao Data de Validade Destino
					SB8->( dbSetOrder( 3 ) ) //"B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)"
					If SB8->( dbSeek( FWxFilial( 'SB8' ) + Padr( aCols[ nLinha ][ nPosCODDes ], TamSx3( 'B8_PRODUTO' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosLOCDes ], TamSx3( 'B8_LOCAL' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosCTLDes ], TamSx3( 'B8_LOTECTL' )[ 1 ] ) + Padr( aCols[ nLinha ][ nPosNLOTE  ], TamSx3( 'B8_NUMLOTE' )[ 1 ] ) ) )
						Do Case
							Case ( Empty( SB8->B8_DTVALID ) )
								lRet := .T.
							Case !( Empty( SB8->B8_DTVALID ) ) .And. ( Empty( aCols[ nLinha ][ nPosDLtDes ] ) )
								aCols[ nLinha ][ nPosDLtDes ] := SB8->B8_DTVALID
								lRet := .T.
							Case !( Empty( SB8->B8_DTVALID ) ) .And. !( Empty( aCols[ nLinha ][ nPosDLtDes ] ) )
								If !( SB8->B8_DTVALID == aCols[ nLinha ][ nPosDLtDes ] )
									aCols[ nLinha ][ nPosDLtDes ] := SB8->B8_DTVALID
									If !lAutoma261
										Help(" ",1,"A240DTVALI")
									EndIf
								EndIf
						EndCase
					EndIf

				EndIf
			EndIf
		EndIf

		//??????????????????????????????
		//?Verifica se o produto origem e destino sao diferentes.  ?
		//??????????????????????????????
		If lRet
			If aCols[nLinha,nPosCODOri]+aCols[nLinha,nPosUmOrig]+aCols[nLinha,nPosLOCOri]+aCols[nLinha,nPosLcZOri]+aCols[nLinha,nPosLotCTL] == aCols[nLinha,nPosCODDes]+aCols[nLinha,nPosUmDest]+aCols[nLinha,nPosLOCDes]+aCols[nLinha,nPosLcZDes]+If(!Empty(aCols[nLinha,nPosCTLDes]),aCols[nLinha,nPosCTLDes],aCols[nLinha,nPosLotCTL])
				Help(" ",1,"MA260IGUAL")
				lRet := .F.
			EndIf
		EndIf

		//??????????????????????????????
		//?Validacao WMS.                                          ?
		//??????????????????????????????
		If lRet .And. !lWmsSD3

			//Retorna falso caso um produto integre com WMS e o outro n?
			If lFnWMSValT
				lRet := WMSValTPOD(aCols[nLinha,nPosCODOri], aCols[nLinha,nPosCODDes])
			EndIf

			If lRet .And. IntWMS(aCols[nLinha,nPosCODDes])
				cCodOrig   := aCols[nLinha,nPosCODOri]
				cLocOrig   := aCols[nLinha,nPosLOCOri]
				cLoclzOrig := aCols[nLinha,nPosLcZOri]
				cCodDest   := aCols[nLinha,nPosCODDes]
				cLocDest   := aCols[nLinha,nPosLOCDes]
				cLoclzDest := aCols[nLinha,nPosLcZDes]
				cNumSerie  := aCols[nLinha,nPosNSer]
				cLoteDigi  := aCols[nLinha,nPosLoTCTL]
				cNumLote   := aCols[nLinha,nPosNLOTE]
				nQuantZ61  := aCols[nLinha,nPosQUANT]
				cServico   := aCols[nLinha,nPosServic]
				If !lWmsNew
					lRet := WMSVldTran(cDocumento,cServico,cCodOrig, cLocOrig, cLoclzOrig, cCodDest, cLocDest, cLoclzDest, cLoteDigi, cNumLote, cNumSerie, nQuantZ61)
				ElseIf !lExecSD3
					If !Empty(cLoclzDest)
						oMovimento := WMSBCCTransferencia():New()
						// Endereco Origem
						oMovimento:oMovEndOri:SetArmazem(cLocOrig)
						oMovimento:oMovEndOri:SetEnder(cLoclzOrig)
						// Endereco Destino
						oMovimento:oMovEndDes:SetArmazem(cLocDest)
						oMovimento:oMovEndDes:SetEnder(cLoclzDest)
						// Produto
						oMovimento:oMovPrdLot:SetArmazem(cLocDest)
						oMovimento:oMovPrdLot:SetProduto(cCodOrig)
						oMovimento:oMovPrdLot:SetLoteCtl(cLoteDigi)
						oMovimento:oMovPrdLot:SetNumLote(cNumLote)
						oMovimento:oMovPrdLot:SetNumSer(cNumSerie)
						// Servi?
						oMovimento:oMovServic:SetServico(cServico)
						oMovimento:oOrdServ:SetDocto(cDocumento)
						oMovimento:oMovPrdLot:SetPrdOri(cCodOrig)
						// Dados Endere? Origem
						oMovimento:oMovEndOri:SetArmazem(cLocOrig)
						oMovimento:oMovEndOri:SetEnder(cLoclzOrig)
						// Dados Endere? Destino
						oMovimento:oMovEndDes:SetArmazem(cLocDest)
						oMovimento:oMovEndDes:SetEnder(cLoclzDest)
						oMovimento:SetQuant(nQuantZ61)
						If !oMovimento:VldGeracao()
							WmsMessagem(oMovimento:GetErro(),"SIGAWMS",5/*MSG_HELP*/)
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		If lRet
			For nX := 1 To Len(aCols)
				/*
				If nX # nLinha .And. !aCols[nx,Len(aCols[nx])] .And. aCols[nLinha,nPosCODOri]+aCols[nLinha,nPosLOCOri]+aCols[nLinha,nPosCODDes]+aCols[nLinha,nPosLOCDes]+aCols[nLinha,nPosNSer]+aCols[nLinha,nPosNLOTE]+aCols[nLinha,nPosLoTCTL]+aCols[nLinha,nPosLcZOri]+aCols[nLinha,nPosLcZDes]+aCols[nLinha,nPosCTLDes] == 									                                     aCols[nX,nPosCODOri]+    aCols[nX,nPosLOCOri]+aCols[nX,    nPosCODDes]+aCols[nX,    nPosLOCDes]+aCols[nX,    nPosNSer]+aCols[nX,    nPosNLOTE]+aCols[nX,    nPosLoTCTL]+aCols[nX,    nPosLcZOri]+aCols[nX,    nPosLcZDes]+aCols[nX,    nPosCTLDes]
					Help(' ',1,'A242JACAD')
					lRet := .F.
				EndIf
				*/
			Next nX
		EndIf

		If lRet .And. lAutoma261
			lRet := U_AZ61Quant(.F.)
		EndIf

		//????????????????????????????????
		//?ExecBlock para validar transferencias.                       ?
		//????????????????????????????????

		If lRet .And. ExistBlock("MAZ61LIN")
			lRet := Execblock("MAZ61LIN",.f.,.f.,{nLinha})
			lRet := If(ValType(LRet)#"L",.T.,lRet)
		EndIf
	EndIf

	If lRet //Origem
		lRet := a241vldfan(aCols[n][nPosCODOri])
	EndIf
	If lRet //Destino
		lRet := a241vldfan(aCols[n][nPosCODDes])
	EndIf

	RestArea(aArea)
Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61VldCod?Autor ?Marcelo Pimentel      ?Data ?29/01/98 ??
???????????????????????????????????????
??escri?o ?Rotina p/ iniciar campos a partir do produto informado.    ??
???????????????????????????????????????
??intaxe   ?AZ61VldCod(ExpN1)                                          ??
???????????????????????????????????????
??arametros?ExpN1 = 1 - inicializa campos do codigo origem             ??
??         ?        2 - inicializa campos do codigo destino            ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function AZ61VldCod(nOrigDest)

	Local aArea       := { Alias(),IndexOrd(),Recno() }
	Local aSB1Area    := { 'SB1', SB1->(IndexOrd()),SB1->(Recno()) }
	Local aSB2Area    := { 'SB2', SB2->(IndexOrd()),SB2->(Recno()) }
	Local aSB8Area    := { 'SB8', SB8->(IndexOrd()),SB8->(Recno()) }
	Local cVar        := &(ReadVar())
	Local cProdRef	  := ''
	Local cCodDest    := ''
	Local cLocalDest  := ''
	Local lRet        := .T.
	Local lContinua	  := .T.
	Local lRastroO    := .F.
	Local lRastroD    := .F.
	Local lLocalizO   := .F.
	Local lLocalizD   := .F.
	Local lCAT83      := .F.
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri 	:= 1 	//Codigo do Produto Origem
	Local nPosDOri	:= 2	//Descricao do Produto Origem
	Local nPosUMOri	:= 3	//Unidade de Medida Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6	//Codigo do Produto Destino
	Local nPosDDes	:= 7	//Descricao do Produto Destino
	Local nPosUMDes	:= 8	//Unidade de Medida Destino
	Local nPosLOCDes 	:= 9	//Armazem Destino
	Local nPosLcZDes 	:= 10	//Localizacao Destino
	Local nPosLoTCTL 	:= 12	//Lote de Controle
	Local nPosNLOTE	:= 13 	//Numero do Lote
	Local nPosDTVAL	:= 14	//Data Valida
	Local nPosPotenc 	:= 15	//Potencia do Lote
	Local nPosDTVALD 	:= 21	//Data Validade de Destino
	Local nPosQUANT	:= 16	//Quantidade
	Local nPosQTSEG	:= 17	//Quantidade na 2a. Unidade de Medida
	Local nPosCAT83O  := aScan(aheader,{|x| Alltrim(x[2])=="D3_CODLAN"})    //Cod.CAT 83 Prod.Origem
	Local nPosCAT83D  := IIF(nPosCAT83O>0,nPosCAT83O+1,0)					 //Cod.CAT 83 Prod.Destino
	Local lExistBlock := ExistBlock("AZ61PROD")
	Local lReferencia := .F.
	Local lGrade      := MaGrade()
	Local lProdDesRef := .F.
	Local aAreaSB1    := {}
	Local lWmsNew	  := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local lExecSD3	  := If(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local cProdAux    := ""

	If ReadVar() # 'M->D3_COD'
		//-- Retorna Integridade do Sistema
		dbSelectArea(aSB1Area[1]); dbSetOrder(aSB1Area[2]); dbGoto(aSB1Area[3])
		dbSelectArea(aSB2Area[1]); dbSetOrder(aSB2Area[2]); dbGoto(aSB2Area[3])
		dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])

		lContinua := .F.
		cProdAux := aCols[n,nPosCODOri]
	Else
		cProdAux := M->D3_COD
	EndIf

	IF lGrade
		cProdRef    := LEFT(cVar,LEN(ALLTRIM(cVar))-4)
		lReferencia := MatGrdPrrf(@cProdRef)
	Endif

	//??????????
	//?Portaria CAT83   |
	//??????????
	If V240CAT83()
		lCAT83:=.T.
	EndIf

	//??????????????????????????
	//?erifica se o usuario tem permissao de inclusao. ?
	//??????????????????????????
	If INCLUI
		If nOrigDest == 1
			lRet := MaAvalPerm(1,{M->D3_COD,"MTA260",3})
		Else
			lRet := MaAvalPerm(1,{aCols[n][nPosCodDes],"MTA260",3})
		EndIf
		If !lRet
			Help(,,1,'SEMPERM')
		EndIf
	EndIf

	If lContinua
		DbSelectArea("SB1")
		SB1->(dbSetOrder(1))
		If M->D3_COD <> cVar
			Help(' ',1,'NOFOUNDSB1')
			//-- Retorna Integridade do Sistema
			dbSelectArea(aSB1Area[1]); dbSetOrder(aSB1Area[2]); dbGoto(aSB1Area[3])
			dbSelectArea(aSB2Area[1]); dbSetOrder(aSB2Area[2]); dbGoto(aSB2Area[3])
			dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])
			lContinua	:= .F.
			lRet		:= .F.
		EndIf
	EndIf

	// Utilizado para verificar se quando o produdo for WMS novo n? efetuar transferencias
	If lRet .And. lWmsNew .And. IntWMS(M->D3_COD) .And. !lExecSD3
		Help(" ",1,"A260WMS",,'Produto informado controlado por WMS n? ?possivel efetuar a transfer?cia! Utilize o monitor de transfer?cia WMS!',1,0)
		lRet:= .F.
		lContinua	:= .F.
	EndIf

	If lContinua
		//-- Preenche Campos do aCols
		SB2->(dbSetOrder(1))
		SB1->(dbSetOrder(1))
		If nOrigDest == 1 .And. SB1->(dbSeek(xFilial('SB1')+M->D3_COD, .F.))
			aCols[n,nPosCODOri]		:= PAD(cVar,len(SD3->D3_COD))
			aCols[n,nPosDOri]		:= IIF(AllTrim(aCols[n,nPosCODOri]) == "","", SB1->B1_DESC)
			aCols[n,nPosUMOri]		:= IIF(AllTrim(aCols[n,nPosCODOri]) == "","", SB1->B1_UM)
			aCols[n,nPosLOCOri]		:= If(SB2->(dbSeek(xFilial('SB2')+cVar+RetFldProd(SB1->B1_COD,"B1_LOCPAD"),.F.)),RetFldProd(SB1->B1_COD,"B1_LOCPAD"),Space(Len(aCols[n,nPosLOCOri])))
			If Empty(aCols[n,nPosCODDes]) .or. aCols[n,nPosCODDes] <> aCols[n,nPosCODOri]
				aCols[n,nPosCODDes]		:= PADR(cVar,Len(SD3->D3_COD))
				aCols[n,nPosDDes]		:= SB1->B1_DESC
				aCols[n,nPosUMDes]		:= SB1->B1_UM
			EndIf
			aCols[n,nPosLcZOri]		:= Space(Len(aCols[n,nPosLcZOri]))
			aCols[n,nPosLoTCTL]		:= Space(Len(aCols[n,nPosLoTCTL]))
			aCols[n,nPosNLOTE]		:= Space(Len(aCols[n,nPosNLOTE]))
		ElseIf nOrigDest == 2 .And. SB1->(dbSeek(xFilial('SB1')+M->D3_COD, .F.))
			aCols[n,nPosCODDes]		:= PAD(cVar,len(SD3->D3_COD))
			aCols[n,nPosDDes]		:= SB1->B1_DESC
			aCols[n,nPosUMDes]		:= SB1->B1_UM
			aCols[n,nPosLOCDes]		:= Space(Len(aCols[n,nPosLOCDes]))
			aCols[n,nPosLcZDes]		:= Space(Len(aCols[n,nPosLcZDes]))
		EndIf
		aCols[n,nPosQTSEG] := ConvUm(cVar,aCols[n,nPosQUANT],aCols[n,nPosQTSEG],2)

		//-- Consiste Igualdade da Origem X Destino
		lRastroO   := Rastro(aCols[n,nPosCODOri])
		lRastroD   := Rastro(aCols[n,nPosCODDes])
		lLocalizO  := Localiza(aCols[n,nPosCODOri],.T.)
		lLocalizD  := Localiza(aCols[n,nPosCODDes],.T.)

		If (!lRastroO .And. !lRastroD) .And. (!lLocalizO .And. lLocalizD)
			If nOrigDest == 1 .And. ;
					(!Empty(aCols[n,nPosLOCOri]) .And. !Empty(aCols[n,nPosCODDes]) .And. !Empty(aCols[n,nPosLOCDes]) .And. ;
					cVar + aCols[n,nPosLOCOri] == aCols[n,nPosCODDes] + aCols[n,nPosLOCDes]) .Or. ;
					nOrigDest == 2 .And. ;
					(!Empty(aCols[n,nPosCODOri]) .And. !Empty(aCols[n,nPosLOCOri]) .And. !Empty(aCols[n,nPosLOCDes]) .And. ;
					aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] == cVar + aCols[n,nPosLOCDes])
				Help(' ',1,'MA260IGUAL')
				//-- Retorna Integridade do Sistema
				dbSelectArea(aSB1Area[1]); dbSetOrder(aSB1Area[2]); dbGoto(aSB1Area[3])
				dbSelectArea(aSB2Area[1]); dbSetOrder(aSB2Area[2]); dbGoto(aSB2Area[3])
				dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])

				lRet 		:= .F.
				lContinua 	:= .F.
			EndIf
		EndIf
	EndIf
	If lContinua
		If !lRastroO
			aCols[n,nPosDTVAL]	:= CriaVar("D3_DTVALID")
			aCols[n,nPosPotenc]	:= CriaVar("D3_POTENCI")
		EndIf
		If lRastroD
			aCols[n,nPosDTVALD]	:= dDataBase
		Else
			aCols[n,nPosDTVALD]	:= CriaVar("D3_DTVALID")
		EndIf
		If lExistBlock
			ExecBlock("AZ61PROD",.F.,.F.,{cVar,nOrigDest})
		EndIf
	EndIf

	//-- Retorna Integridade do Sistema
	dbSelectArea(aSB1Area[1]); dbSetOrder(aSB1Area[2]); dbGoto(aSB1Area[3])
	dbSelectArea(aSB2Area[1]); dbSetOrder(aSB2Area[2]); dbGoto(aSB2Area[3])
	dbSelectArea(aSB8Area[1]); dbSetOrder(aSB8Area[2]); dbGoto(aSB8Area[3])
	dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])
Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Quant ?Autor ?Marcelo Pimentel      ?Data ?29/01/98 ??
???????????????????????????????????????
??escri?o ?Rotina p/ iniciar campos a partir da Quantidade Informada. ??
???????????????????????????????????????
??intaxe   ?A260Quant(ExpN1)                                           ??
???????????????????????????????????????
??arametros?ExpL1 = Flag indicando se valida pela digitacao ou nao     ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MatAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
User Function AZ61Quant(lDigita)

	Local aArea       := GetArea()
	Local aSB2Area    := { 'SB2', SB2->(IndexOrd()),SB2->(Recno()) }
	Local aSB8Area    := { 'SB8', SB8->(IndexOrd()),SB8->(Recno()) }
	Local aSBEArea    := { 'SBE', SBE->(IndexOrd()),SBE->(Recno()) }
	Local nRecSB8     := 0
	Local nOrdSB8     := 0
	Local lRet        := .T.
	Local lContinua	  := .T.
	Local cReadVar    := AllTrim(Upper(ReadVar()))
	Local cLocDest    := ""
	Local cLoclzDest  := ""
	Local nQuant      := 0
	Local nQuant2UM   := 0
	Local nSaldo      := 0
	Local lPermNegat  := GetMV('MV_ESTNEG') == 'S'
	Local lRastroL    := .F.
	Local lRastroS    := .F.
	Local lLocalizO   := .F.
	Local lLocalizD   := .F.
	Local lValidPE
	Local lMTZ61UM    	:= ExistBlock("MTZ61UM")
	Local nX		  		:= 0
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri 	:= 1 	//Codigo do Produto Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6	//Codigo do Produto Destino
	Local nPosLOCDes 	:= 9	//Armazem Destino
	Local nPosLcZDes 	:= 10	//Localizacao Destino
	Local nPosNSer		:= 11	//Numero de Serie
	Local nPosLoTCTL 	:= 12	//Lote de Controle
	Local nPosNLOTE		:= 13 	//Numero do Lote
	Local nPosQUANT		:= 16	//Quantidade
	Local nPosQTSEG		:= 17	//Quantidade na 2a. Unidade de Medida
	Local cHelp      	:= ""
	Local cLocCQ     	:= GetMvNNR('MV_CQ','98')
	Local lEmpPrev   	:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
	Local lGrade     	:= MaGrade()
	Local lReferencia	:= .F.
	Local lSaldoSemR 	:= Nil
	Local lWmsNew	  := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local oSaldoWMS   := Iif(lWmsNew,WMSDTCEstoqueEndereco():New(),Nil)
	Local lWmsSD3     := If(!(Type('lExecWms')=='U'), lExecWms, .F.)

	SB2->(dbSetOrder(1))

	cLocDest   := aCols[Len(aCols),nPosLOCDes]
	cLoclzDest := aCols[Len(aCols),nPosLcZDes]

	//-- Verifica se produto eh referencia de grade
	If lGrade
		cVar:=aCols[n,nPosCODOri]
		lReferencia := MatGrdPrrf(@cVar)
	Endif

	If !lReferencia
		If lDigita .And. cReadVar # 'M->D3_QUANT' .And. cReadVar # 'M->D3_QTSEGUM'
			lContinua := .F.
		EndIf

		If lContinua .And. lDigita .And. Empty(&(ReadVar()))
			If lDigita .And. cReadVar # 'M->D3_QUANT' .And. cReadVar # 'M->D3_QTSEGUM'
				Help(' ',1,'NVAZIO')
				lRet		:= .F.
				lContinua	:= .F.
			Endif
		EndIf

		If lContinua .And. lDigita .And. QtdComp(&(ReadVar())) < QtdComp(0)
			Help(' ',1,'POSIT')
			lRet		:= .F.
			lContinua	:= .F.
		EndIf

		If lContinua
			If lDigita
				If cReadVar == 'M->D3_QUANT'
					nQuant    := &(ReadVar())
					nQuant2UM := ConvUm(aCols[n,nPosCODOri],&(ReadVar()),aCols[n,nPosQTSEG],2)
				Else
					nQuant    := ConvUm(aCols[n,nPosCODOri],aCols[n,nPosQUANT],&(ReadVar()),1)
					nQuant2UM := &(ReadVar())
				EndIf
			Else
				nQuant    := aCols[n,nPosQUANT]
				nQuant2UM := aCols[n,nPosQTSEG]
			EndIf
			If Empty(aCols[n,nPosCODOri]) .Or. Empty(aCols[n,nPosCODDes])
				Help(' ',1,'MA260OBR')
				lRet		:= .F.
				lContinua	:= .F.
			EndIf
		EndIf

		If lContinua
			lRastroL  := Rastro(aCols[n,nPosCODOri],'L')
			lRastroS  := Rastro(aCols[n,nPosCODOri],'S')
			lLocalizO := Localiza(aCols[n,nPosCODOri],.T.)
			lLocalizD := Localiza(aCols[n,nPosCODDes],.T.)

			//-- Produtos com Saldo Insuficienne
			//-- Negativo - Impede Movimentacoes que causem Saldo Negativo no SB2
			If !lPermNegat
				SB2->(DbSetOrder(1))
				If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri], .F.))
					Help(' ',1,'A260Local')
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
				If lContinua
					//-- Subtrai a Reserva do Saldo a ser Retornado?
					If aZ61IntWMS(aCols[n,nPosCODOri]) .And. lLocalizO .And. aCols[n,nPosCODOri]==aCols[n,nPosCODDes] .And. aCols[n,nPosLOCOri]==aCols[n,nPosLOCDes] .And. aCols[n,nPosLcZOri]#aCols[n,nPosLcZDes]
						lSaldoSemR := .F.
					EndIf
					nSaldo := SaldoMov(Nil,Nil,Nil,If(mv_par03==1,.F.,Nil),Nil,Nil, lSaldoSemR, If(Type('dAZ61Data') == "D",dAZ61Data,dDataBase))
					For nX := If(!lDigita,n+1,1) to Len(aCols)
						If nX # n
							If !aCols[nX,Len(aCols[nX])].And.(If(lRastroL,aCols[n,nPosLoTCTL]==aCols[nX,nPosLoTCTL],.T.).And.If(lRastroS,aCols[n,nPosNLOTE]==aCols[nX,nPosNLOTE],.T.))
								If aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] == aCols[nX,nPosCODOri] + aCols[nX,nPosLOCOri]
									nSaldo -= aCols[nX,nPosQUANT]
								ElseIf aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] == aCols[nX,nPosCODDes] + aCols[nX,nPosLOCDes]
									nSaldo += aCols[nX,nPosQUANT]
								EndIf
							EndIf
						EndIf
					Next nX
					/*
					If QtdComp(nSaldo) < QtdComp(nQuant)
						Help(' ',1,'MA240NEGAT')
						lRet		:= .F.
						lContinua	:= .F.
					EndIf
					*/
				EndIf
			EndIf

			//-- Produtos com Rastro ou Localizacao ou integracao com WMS
			//-- Negativo - Impede Movimentacoes que causem Saldo Negativo no SB2
			If !lPermNegat .or. (lRastroL .Or. lRastroS) .or. lLocalizO .Or. aZ61IntWMS(aCols[n,nPosCODOri])
				SB2->(DbSetOrder(1))
				If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri], .F.))
					Help(' ',1,'A260Local')
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
				If lContinua
					//-- Subtrai a Reserva do Saldo a ser Retornado?
					If aZ61IntWMS(aCols[n,nPosCODOri]) .And. lLocalizO .And. aCols[n,nPosCODOri]==aCols[n,nPosCODDes] .And. aCols[n,nPosLOCOri]==aCols[n,nPosLOCDes] .And. aCols[n,nPosLcZOri]#aCols[n,nPosLcZDes]
						lSaldoSemR := .F.
					EndIf
					nSaldo := SaldoMov(Nil,Nil,Nil,If(mv_par03==1,.F.,Nil),Nil,Nil, lSaldoSemR, If(Type('dAZ61Data') == "D",dAZ61Data,dDataBase))
					For nX := If(!lDigita,n+1,1) to Len(aCols)
						If nX # n
							If !aCols[nX,Len(aCols[nX])].And.(If(lRastroL,aCols[n,nPosLoTCTL]==aCols[nX,nPosLoTCTL],.T.).And.If(lRastroS,aCols[n,nPosNLOTE]==aCols[nX,nPosNLOTE],.T.))
								If aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] == aCols[nX,nPosCODOri] + aCols[nX,nPosLOCOri]
									nSaldo -= aCols[nX,nPosQUANT]
								ElseIf aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] == aCols[nX,nPosCODDes] + aCols[nX,nPosLOCDes]
									nSaldo += aCols[nX,nPosQUANT]
								EndIf
							EndIf
						EndIf
					Next nX
					/*
					If QtdComp(nSaldo) < QtdComp(nQuant)
						Help(' ',1,'MA240NEGAT')
						lRet		:= .F.
						lContinua	:= .F.
					EndIf
					*/
				EndIf
			EndIf
		EndIf

		//-- Produto Origem com Localizacao - Impede Movimentacoes com
		//-- Quantidades maiores que o Saldo no SBF
		If lContinua .And. !lWmsSD3
			If lLocalizO
				If !Empty(aCols[n,nPosLcZDes]).And. (!SBE->(dbSeek(xFilial('SBE')+aCols[n,nPosLOCDes]+aCols[n,nPosLcZDes]))) .AND. lAutoma261
					Help(' ',1,'MA260LOC')
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
				If Empty(aCols[n,nPosLcZOri]+aCols[n,nPosNSer]) .Or. ;
						(!Empty(aCols[n,nPosLcZOri]) .And. !SBE->(dbSeek(xFilial('SBE')+aCols[n,nPosLOCOri]+aCols[n,nPosLcZOri],.F.))) .AND. lContinua
					Help(' ',1,'MA260OBR')
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
				If lContinua
					If !(lWmsNew .And. aZ61IntWMS(aCols[n,nPosCODOri]))
						nSaldo := SaldoSBF(aCols[n,nPosLOCOri],aCols[n,nPosLcZOri],aCols[n,nPosCODOri],aCols[n,nPosNSer],aCols[n,nPosLoTCTL],aCols[n,nPosNLOTE])
					Else
						nSaldo := oSaldoWMS:GetSldWMS(aCols[n,nPosCODOri],aCols[n,nPosLOCOri],aCols[n,nPosLcZOri],aCols[n,nPosLoTCTL],aCols[n,nPosNLOTE],aCols[n,nPosNSer])
					EndIf
					For nX := If(!lDigita,n+1,1) to Len(aCols)
						If nX # n
							If !aCols[nX,Len(aCols[nX])].And.(If(lRastroL,aCols[n,nPosLoTCTL]==aCols[nX,nPosLoTCTL],.T.).And.If(lRastroS,aCols[n,nPosNLOTE]==aCols[nX,nPosNLOTE],.T.))
								If aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] + aCols[n,nPosCODDes] + aCols[n,nPosNSer] == aCols[nX,nPosCODOri] + aCols[nX,nPosLcZOri] + aCols[nX,nPosLcZOri] + aCols[nX,nPosNSer]
									nSaldo -= aCols[nX,nPosQUANT]
								ElseIf aCols[n,nPosCODOri] + aCols[n,nPosLOCOri]  + aCols[n,nPosLcZOri] + aCols[n,nPosNSer] == aCols[nX,nPosCODDes] + aCols[nX,nPosLOCDes] + aCols[nX,nPosLcZDes] + aCols[nX,nPosNSer]
									nSaldo += aCols[nX,nPosQUANT]
								EndIf
							EndIf
						EndIf
					Next nX
					If QtdComp(nSaldo) < QtdComp(nQuant)
						Help(' ',1,'SALDOLOCLZ')
						lRet		:= .F.
						lContinua	:= .F.
					EndIf
				EndIf
			EndIf
		EndIf

		//-- Produto Destino com Localizacao - Impede Movimentacoes com
		//-- Quantidades superiores a Capacidade no SBE
		If lContinua .And. lLocalizD .And. !lWmsSD3
			If !Empty(aCols[n,nPosLcZDes]) .And. !SBE->(dbSeek(xFilial('SBE')+aCols[n,nPosLOCDes]+aCols[n,nPosLcZDes])) .AND. lAutoma261
				Help(' ',1,'MA260LOC')
				lRet		:= .F.
				lContinua	:= .F.
			EndIf
			If (aCols[n,nPosLOCDes] == cLocCQ .And. Empty(aCols[n,nPosLcZDes]+aCols[n,nPosNSer])) .Or. ;
					(!Empty(aCols[n,nPosLcZDes]) .And. !SBE->(dbSeek(xFilial('SBE')+aCols[n,nPosLOCDes]+aCols[n,nPosLcZDes],.F.))) .AND. lContinua
				Help(' ',1,'MA260OBR')
				lRet		:= .F.
				lContinua	:= .F.
			EndIf
			If lContinua
				If !(lWmsNew .And. aZ61IntWMS(aCols[n,nPosCODOri]))
					nSaldo := QuantSBF(aCols[n,nPosLOCDes],aCols[n,nPosLcZDes],aCols[n,nPosCODDes])
				Else
					nSaldo := oSaldoWMS:GetSldWMS(aCols[n,nPosCODDes],aCols[n,nPosLOCDes],aCols[n,nPosLcZDes])
				EndIf
				For nX := If(!lDigita,n+1,1) to Len(aCols)
					If nX # n
						If !aCols[nX,Len(aCols[nX])].And.(If(lRastroL,aCols[n,nPosLoTCTL]==aCols[nX,nPosLoTCTL],.T.).And.If(lRastroS,aCols[n,nPosNLOTE]==aCols[nX,nPosNLOTE],.T.))
							If	aCols[n,nPosCODDes] + aCols[n,nPosLOCDes] + aCols[n,nPosLcZDes] == aCols[nX,nPosCODOri] + aCols[nX,nPosLOCOri] + aCols[nX,nPosLcZOri]
								nSaldo -= aCols[nX,nPosQUANT]
							ElseIf aCols[n,nPosCODDes] + aCols[n,nPosLOCDes] + aCols[n,nPosLcZDes] == aCols[nX,nPosCODDes] + aCols[nX,nPosLOCDes] + aCols[nX,nPosLcZDes]
								nSaldo += aCols[nX,nPosQUANT]
							EndIf
						EndIf
					EndIf
				Next nX
				If SBE->(!Eof()) .And. QtdComp(SBE->BE_CAPACID)>QtdComp(0) .And. (QtdComp(SBE->BE_CAPACID)<QtdComp(nQuant+QuantSBF(cLocDest, cLoclzDest))) .And. !aZ61IntWMS(aCols[n,nPosCODDes])
					Help(' ',1,'MA265CAPAC')
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
			EndIf
		EndIf

		//-- Produto Origem com Rastro - Impede Movimentacoes com Quantidades
		//-- maiores que as existentes no Lote/SubLote de Origem
		If lContinua .And. (lRastroL .Or. lRastroS)
			If lRastroL
				dbSelectArea("SB8")
				SB8->(dbSetOrder(3))
				If !SB8->(dbSeek(xFilial('SB8')+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri]+aCols[n,nPosLoTCTL],.F.))
					Help(' ', 1, 'A240LOTERR')
					lRet		:= .F.
					lContinua	:= .F.
				Else
					nSaldo := SaldoLote(aCols[n,nPosCODOri],aCols[n,nPosLOCOri],aCols[n,nPosLoTCTL],NIL,NIL,NIL,NIL,dAZ61Data)
				EndIf
			ElseIf lRastroS
				SB8->(dbSetOrder(2))
				If !SB8->(dbSeek(xFilial('SB8')+aCols[n,nPosNLOTE]+aCols[n,nPosLoTCTL]+aCols[n,nPosCODOri]+aCols[n,nPosLOCOri],.F.))
					Help(' ', 1, 'A240LOTERR')
					lRet		:= .F.
					lContinua	:= .F.
				Else
					nSaldo := SB8Saldo(nil,.T.,nil,nil,nil,lEmpPrev,nil,dAZ61Data)
				EndIf
			EndIf
			If lContinua
				For nX := If(!lDigita,n+1,1) to Len(aCols)
					If nX # n
						If !aCols[nX,Len(aCols[nX])].And.(If(lRastroL,aCols[n,nPosLoTCTL]==aCols[nX,nPosLoTCTL],.T.).And.If(lRastroS,aCols[n,nPosNLOTE]==aCols[nX,nPosNLOTE],.T.))
							If aCols[n,nPosCODOri] + aCols[n,nPosLOCOri] + aCols[n,nPosLoTCTL] + If(lRastroS,aCols[n,nPosNLOTE],'') == aCols[nX,nPosCODOri] + aCols[nX,nPosLOCOri] + aCols[nX,nPosLoTCTL] + If(lRastroS,aCols[nX,nPosNLOTE],'')
								nSaldo -= aCols[nX,nPosQUANT]
							EndIf
						EndIf
					EndIf
				Next nX
				/*
				If QtdComp(nSaldo) < QtdComp(nQuant)
					cHelp:=Substr(STR0006,1,4)+" "+aCols[n,nPosCODOri]+Substr(STR0018,1,4)+" "+aCols[n,nPosLoTCTL]
					Help(" ",1,"MA240NEGAT",,cHelp,4,1)
					lRet		:= .F.
					lContinua	:= .F.
				EndIf
				*/
			EndIf
		EndIf
		If lContinua
			aCols[n,nPosQUANT] := nQuant
			aCols[n,nPosQTSEG] := nQuant2UM
		EndIf
		//-- Retorna Integridade do Sistema
		SB2->(dbSelectArea(aSB2Area[1])); SB2->(dbSetOrder(aSB2Area[2])); SB2->(dbGoto(aSB2Area[3]))
		SB8->(dbSelectArea(aSB8Area[1])); SB8->(dbSetOrder(aSB8Area[2])); SB8->(dbGoto(aSB8Area[3]))
		SBE->(dbSelectArea(aSBEArea[1])); SBE->(dbSetOrder(aSBEArea[2])); SBE->(dbGoto(aSBEArea[3]))
		RestArea(aArea)
	Endif
	If lMTZ61UM
		lValidPE := ExecBlock("MTZ61UM",.F.,.F.,{nQuant,nQuant2UM,lRet})
		If ValType(lValidPE) == "L"
			lRet := lValidPE
		EndIf
	EndIf

Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Locali?Autor ?Marcelo Pimentel      ?Data ?30/01/98 ??
???????????????????????????????????????
??escri?o ?Valida as Localizacoes da transferencia                    ??
???????????????????????????????????????
??intaxe   ?AZ61Locali(ExpN1)                                          ??
???????????????????????????????????????
??arametros?ExpN1 = Indica se e Origem / Destino                       ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
User Function AZ61Locali(nOrigDest)
	Local aArea      := { Alias()	, IndexOrd() , Recno() }
	Local aSBEArea   := { 'SBE'	, SBE->(IndexOrd()) , SBE->(Recno()) }
	Local lRet       := .T.
	Local lContinua	 := .T.
	Local cLocaliz   := &(ReadVar())

	nOrigDest := If(nOrigDest==NIL,1,nOrigDest)

	If ReadVar() # 'M->D3_LOCALIZ'
		lContinua := .F.
	EndIf
	If lContinua
		If nOrigDest == 1
			If Empty(aCols[n,1]) .Or. Empty(aCols[n,4])
				Help(' ',1,'MA260OBR')
				lRet:=.F.
			EndIf
			If lRet
				lRet:=ExistCpo('SBE',aCols[n,4]+cLocaliz)
			EndIf
			If lRet .And. !Localiza(aCols[n,1],.T.)
				&(ReadVar()) := Space(Len(&(ReadVar())))
			EndIf
		Else
			If Empty(aCols[n,6]) .Or. Empty(aCols[n,9])
				Help(' ',1,'MA260OBR')
				lRet:=.F.
			EndIf

			If lRet .And. Localiza(aCols[n,6],.T.)
				lRet:=ExistCpo('SBE',aCols[n,9]+cLocaliz)
				If lRet
					lRet:=ProdLocali(aCols[n,6],aCols[n,9],cLocaliz)
				EndIf
			Else
				&(ReadVar()) := Space(Len(&(ReadVar())))
			EndIf
		EndIf
	EndIf
	//-- Retorna Integridade do Sistema
	dbSelectArea(aSBEArea[1]); dbSetOrder(aSBEArea[2]); dbGoto(aSBEArea[3])
	dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])
Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Almox  ?Autor ?Fernando Joly Siquini ?Data ?04/03/99 ??
???????????????????????????????????????
??escri?o ?Valida?o do campo Local                                    ??
???????????????????????????????????????
??intaxe   ?AZ61Almox(ExpN1)                                            ??
???????????????????????????????????????
??arametros?ExpN1 = Indica se e Origem / Destino                        ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                   ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                     ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
User Function AZ61Almox(nOrigDest,cLocOrig)
	Static lZ61Local  := NIL
	Local aArea       := { Alias()	, IndexOrd() , Recno() }
	Local aSB2Area    := { 'SB2'	, SB2->(IndexOrd()) , SB2->(Recno()) }
	Local lRet        := .T.
	Local lContinua	  := .T.
	Local lRastroO    := .F.
	Local lRastroD    := .F.
	Local lLocalizO   := .F.
	Local lLocalizD   := .F.
	Local cLocal      := IIF (lAutoma261,cLocOrig , &(ReadVar()))
	Local cLocCQ      := GetMvNNR('MV_CQ','98')
	Local cLocProc	:= GetMvNNR('MV_LOCPROC','99')
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosCODOri  := 1	//Codigo do Produto Origem
	Local nPosLOCOri  := 4	//Armazem Origem
	Local nPosCODDes  := 6	//Codigo do Produto Destino
	Local nPosLOCDes  := 9	//Armazem Destino
	Local lGrade      := MaGrade()
	Local cVar        :=" "
	Local lReferencia := .F.
	Local lSaldoSemR  := Nil
	Local lWmsSD3     := If(!(Type('lExecWms')=='U'), lExecWms, .F.)

	Default cLocOrig := ''

	cLocal    := If(Empty(cLocOrig),&(ReadVar()),cLocOrig)
	lZ61Local := If(lZ61Local==NIL,ExistBlock("AZ61LOC"),lZ61Local)
	nOrigDest := If(nOrigDest==NIL,1,nOrigDest)

	If Empty(cLocOrig) .And. ReadVar() # 'M->D3_LOCAL'
		lContinua := .F.
	EndIf


	If lContinua .And. Empty(cLocal)
		if lAutoma261
			Help(' ',1,'AZ61VZNNR',,'N'+chr(37494)+' informado dep'+chr(39630)+'ito origem',1,1)
		Else
			Help(' ',1,'NVAZIO')
		Endif
		lContinua 	:= .F.
		lRet		:= .F.
	EndIf

	If lContinua
		SB2->(dbSetOrder(1))

		If nOrigDest == 1

			If Empty(aCols[n,nPosCODOri])
				Help(' ',1,'MA260OBR')
				lContinua	:= .F.
				lRet		:= .F.
			EndIf

			If lContinua
				lRastroO  := Rastro(aCols[n,nPosCODOri])
				lLocalizO := Localiza(aCols[n,nPosCODOri],.T.)

				If !lAutoma261 .and. cLocal == cLocCQ .and. !lLocalizO
					Help(' ',1,'A260LOCCQ')
					lContinua	:= .F.
					lRet		:= .F.
				ElseIf !lAutoma261 .and. cLocal == cLocProc .And. If(Empty(aCols[n,nPosCODOri]).Or.!FindFunction('A260ApropI'),.T.,A260ApropI(aCols[n,nPosCODOri]))	//-- Soh impede transferencia do Armazem de Processo se o Produto for de "Apropriacao Indireta"
					If Aviso(STR0026,STR0052,{STR0050,STR0051}) == 2
						lRet:=.F.
						lContinua	:= .F.
					EndIf
				EndIf
			EndIf
			If lContinua .And. lZ61Local
				ExecBlock("AZ61LOC",.F.,.F., {aCols[n,nPosCODOri],cLocal,nOrigDest})
			EndIf

			If lContinua
				If lGrade
					cVar:=aCols[n,nPosCODOri]
					lReferencia := MatGrdPrrf(@cVar)
				Endif
				If !lReferencia
					dbSelectArea("SB2")
					dbSetOrder(1)
					If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODOri]+cLocal,.F.))
						Help(' ',1,'A260Local')
						lContinua	:= .F.
						lRet		:= .F.
					EndIf
					If !ExistCpo("NNR",cLocal)//verifica se a versao suporta a tabela NNR
						lContinua := .F.
						lRet		:= .F.
					Endif
				EndIf
			EndIf
			If lContinua .And. !Empty(aCols[n,nPosCODDes]) .And. !Empty(aCols[n,nPosLOCDes])
				lRastroD  := Rastro(aCols[n,nPosCODDes])
				lLocalizD := Localiza(aCols[n,nPosCODDes],.T.)
				If (!lRastroO .And. !lRastroD) .And. (!lLocalizO .And. !lLocalizD) .And. ;
						aCols[n,nPosCODOri]+cLocal == aCols[n,nPosCODDes]+aCols[n,nPosLOCDes]
					Help(' ',1,'MA260IGUAL')
					lContinua	:= .F.
					lRet		:= .F.
				EndIf
			EndIf

		Else

			If Empty(aCols[n,nPosCODDes])
				Help(' ',1,'MA260OBR')
				lContinua	:= .F.
				lRet		:= .F.
			EndIf

			If lContinua
				lRastroD  := Rastro(aCols[n,nPosCODDes])
				lLocalizD := Localiza(aCols[n,nPosCODDes],.T.)

				If lZ61Local
					ExecBlock("AZ61LOC",.F.,.F., {aCols[n,nPosCODDes],cLocal,nOrigDest})
				EndIf
				If lGrade
					cVar:=aCols[n,nPosCODDes]
					lReferencia := MatGrdPrrf(@cVar)
				Endif

				If !lReferencia
					If !SB2->(dbSeek(xFilial('SB2')+aCols[n,nPosCODDes]+cLocal,.F.)) .And. GetMV('MV_VLDALMO') == 'S'
						RecLock("SB2",.T.)
						SB2->B2_FILIAL := xFilial("SB2")
						SB2->B2_COD    := aCols[n,nPosCODDes]
						SB2->B2_LOCAL  := cLocal
						MSUnlock()
						//Help(' ',1,'A260Local')
						//lContinua	:= .F.
						//lRet		:= .F.
					EndIf
					If !ExistCpo("NNR",cLocal)//Verifica se a versao suporta a tabela NNR
						lContinua := .F.
						lRet		:= .F.
					Endif
				Endif
				If lContinua
					If aCols[Len(aCols),nPosLOCOri] == cLocCq .AND. cLocal != cLocCq
						Help(' ',1,'A260LOCCQ')
						lContinua	:= .F.
						lRet		:= .F.
					EndIf
				EndIf
				If lContinua .And. cLocal == cLocProc .And. If(Empty(aCols[n,nPosCODDes]),.T.,A260ApropI(aCols[n,nPosCODDes]))	//-- Soh impede transferencia do Armazem de Processo se o Produto for de "Apropriacao Indireta"
					If !lAutoma261 .and. lContinua .And. cLocal == cLocProc .And. If(Empty(aCols[n,nPosCODDes]).Or.!FindFunction('A260ApropI'),.T.,A260ApropI(aCols[n,nPosCODDes]))	//-- Soh impede transferencia do Armazem de Processo se o Produto for de "Apropriacao Indireta"
						If Aviso(STR0026,STR0053,{STR0050,STR0051}) == 2
							lRet:=.F.
							lContinua	:= .F.
						EndIf
					EndIf
				EndIf
			EndIf
			If lContinua .And. !Empty(aCols[n,nPosCODOri]) .And. !Empty(aCols[n,nPosLOCOri])
				lRastroO  := Rastro(aCols[n,nPosCODOri])
				lLocalizO := Localiza(aCols[n,nPosCODOri],.T.)
				If (!lRastroO .And. !lRastroD) .And. ;
						(!lLocalizO .And. !lLocalizD) .And. ;
						aCols[n,nPosCODOri]+aCols[n,nPosLOCOri] == aCols[n,nPosCODDes]+cLocal
					Help(' ',1,'MA260IGUAL')
					lContinua	:= .F.
					lRet		:= .F.
				EndIf
			EndIf
		EndIf
	EndIf
	//-- Retorna Integridade do Sistema
	dbSelectArea(aSB2Area[1]); dbSetOrder(aSB2Area[2]); dbGoto(aSB2Area[3])
	dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])

Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Data  ?Autor ?Marcelo Pimentel      ?Data ?30/01/98 ??
???????????????????????????????????????
??escri?o ?Valida?o do campo Data de Emissao                         ??
???????????????????????????????????????
??arametros?Nenhum													  ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function AZ61Data()

	Local dData
	Local dDataFec := MVUlmes()
	Local lRet := .T.

	dData:= &(ReadVar())
	//????????????????????????????????
	//?Verificar data do ultimo fechamento em SX6.                  ?
	//????????????????????????????????
	If dDataFec >= dData
		Help ( ' ', 1, 'FECHTO' )
		lRet := .F.
	EndIf

Return lRet



/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61DesAtu?Autor ?Marcelo Pimentel      ?Data ?5/02/98  ??
???????????????????????????????????????
??escri?o ?Estorno                                                    ??
???????????????????????????????????????
??arametros?Nenhum													  ??
???????????????????????????????????????
??etorno   ?.T.                                                        ??
???????????????????????????????????????
??Uso      ?MataZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function aZ61Desatu()

	Local aArea      := { Alias()	, IndexOrd() , Recno() }
	Local aSD3Area   := { 'SD3'	, SD3->(IndexOrd()) , SD3->(Recno()) }
	Local bCampo     := {|nCPO| Field(nCPO) }
	Local aCusto     := {}
	Local lRet       := .T.
	Local lContinua	 := .T.
	Local cServico   := ""
	Local nX         := 0
	Local lQualyCQ   := .F.
	Local cMemo
	Local cVar
	Local cVar1
	Local nMem
	Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local ld3kLimp	:= Findfunction('MatLimpD3K')

	//????????????????????????????????????
	//?Inicializa variaveis para campos Memos Virtuais             		 ?
	//????????????????????????????????????
	If Type("aMemos")=="A"  .And. Len(aMemos) > 0
		For nMem :=1 To Len(aMemos)
			cMemo := aMemos[nMem][2]
			If ExistIni(cMemo)
				&cMemo := InitPad(SX3->X3_RELACAO)
			Else
				&cMemo := ""
			EndIf
		Next nMem
	EndIf

	//-- Verifica se o custo medio ?calculado On-Line e, se necessario, cria o
	//-- cabecalho do arquivo de Prova
	If cCusMed == 'O' .And. lCriaHeade
		lCriaHeade := .F.
		If (nHdlPrv := HeadProva(cLoteEst,'MATAZ61',Subs(cUsuario,7,6),@cArquivo)) <= 0
			//-- Retorna Integridade do Sistema
			dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])
			lContinua := .F.
		EndIf
	EndIf

	If lContinua
		//-- Estorna a Movimenta?o Atual
		RecLock('SD3',.F.)
		Replace SD3->D3_ESTORNO With 'S'
		MsUnlock()

		//-- Salva o Conteudo dos campos da Movimenta?o Atual
		For nX := 1 to SD3->(fCount())
			M->&(Eval(bCampo,nX)) := SD3->(FieldGet(nX))
		Next nX

		//-- Cria o registro de estorno com mesmos dados do original
		RecLock('SD3',.T.)
		For nX := 1 to SD3->(fCount())
			SD3->(FieldPut(nX,M->&(Eval(bCampo,nX))))
		Next nX
		Replace SD3->D3_CF  With If(Left(SD3->D3_CF,1)=='D','R','D')+Subs(SD3->D3_CF,2,2),;
			SD3->D3_TM      With If(Left(SD3->D3_CF,1)=='D','499','999'),;
			SD3->D3_CHAVE   With 'E'+If(Left(SD3->D3_CF,1)=='D','9','0'),;
			SD3->D3_USUARIO With CUSERNAME,;
			SD3->D3_SERVIC  With ''
		//???????????????????????????????????
		//?storna os campos Memos Virtuais					 				  ?
		//???????????????????????????????????
		If Type("aMemos") == "A"  .And.  Len(aMemos) > 0
			For nMem := 1 to Len(aMemos)
				cVar := aMemos[nMem][2]
				MSMM(,TamSx3(aMemos[nMem][2])[1],,&cVar,1,,,"SD3",aMemos[nMem][1])
			Next nMem
		EndIf
		MsUnlock()
		If ld3kLimp
			MatLimpD3K(SD3->D3_COD,SD3->D3_NUMSEQ)
		EndIf

		aAdd(aRegSD3,SD3->(Recno()))
		//-- Ponto de Entrada apos a gravacao do estorno
		If lMAZ61Exc
			ExecBlock('MAZ61EXC',.F.,.F.)
		EndIf
		//-- Pega o custo da movimentacao
		aCusto := PegaCusD3()

		//-- Atualiza o saldo atual (VATU) com os dados do SD3
		B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,NIL,NIL,NIL,cServico)

		//-- Verifica se o custo medio ?calculado On-Line
		If cCusMed == 'O'
			//??????????????????????????
			//?Gera o lancamento no arquivo de prova           ?
			//??????????????????????????
			If SD3->D3_TM <= "500"
				nTotal+=DetProva(nHdlPrv,"672","MATAZ61",cLoteEst)
			Else
				nTotal+=DetProva(nHdlPrv,"670","MATAZ61",cLoteEst)
			EndIf
			If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
				aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
			Else
				aCtbDia := {}
			EndIF
		EndIf

		//-- Integracao SIGAWMS - Realiza o Estorno do Servico
		If aZ61IntWMS(SD3->D3_COD) .And. !Empty(SD3->D3_SERVIC)
			If !lWmsNew
				cServico := SD3->D3_SERVIC
				WmsDelDCF('1','SD3')
			Else
				// Estorno [NOVO WMS]
				oOrdSerDel := WMSDTCOrdemServicoDelete():New()
				oOrdSerDel:SetIdDCF(SD3->D3_IDDCF)
				If oOrdSerDel:LoadData()
					If !oOrdSerDel:DeleteDCF()
						Help( ,1,"SIGAWMS",,oOrdSerDel:GetErro(),1,0)
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Return lRet


/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?ShowF4   ?Autor ?Fernando Joly Siquini ?Data ?13/04/99 ??
???????????????????????????????????????
??escri?o ?Chamada da funcao F4                                       ??
???????????????????????????????????????
??arametros?Nenhum/nao utilizados									  ??
???????????????????????????????????????
??etorno   ?Nenhum		                                              ??
???????????????????????????????????????
??Uso      ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function ShowF4(a,b,c)
	Local nHdl := GetFocus()
	If AllTrim(Upper(ReadVar())) $ 'M->D3_COD?->D3_QUANT'
		MaViewSB2(aCols[n,1])
	ElseIf AllTrim(Upper(ReadVar())) $ 'M->D3_NUMLOTE?->D3_LOTECTL'
		If oGet:oBrowse:nColPos == 20
			F4Lote(,,,   'AZ61',aCols[n,6],aCols[n,9],NIL,aCols[n,10],2,,,.F.)
		Else
			F4Lote(,,,   'AZ61',aCols[n,1],aCols[n,4],NIL,aCols[n,5],2)
		EndIf
	ElseIf AllTrim(Upper(ReadVar())) == 'M->D3_LOCALIZ' .Or. AllTrim(Upper(ReadVar())) == 'M->D3_NUMSERI'
		If oGet:oBrowse:nColPos == 10
			F4Localiz(,,,   'AZ61', aCols[n,6], aCols[n,9],, ReadVar(),.F.,,(AllTrim(Upper(ReadVar()))=='M->D3_NUMSERI') )
		Else
			F4Localiz(,,,   'AZ61', aCols[n,1], aCols[n,4],, ReadVar(),,,(AllTrim(Upper(ReadVar()))=='M->D3_NUMSERI') )
		EndIf
	EndIf
	SetFocus(nHdl)
Return NIL

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61Lote   ?Autor ?Fernando Joly Siquini ?Data ?24/02/99 ??
???????????????????????????????????????
??escri?o ?Valida?o referente aos campos de Lote e Sub-Lote           ??
???????????????????????????????????????
??intaxe   ?AZ61Lote(ExpN1)                                             ??
???????????????????????????????????????
??arametros?ExpN1 - Indica validacao 1 - Data de Validade/Potencia 	   ??
??         ?        2 - Data de Validade de Destino                     ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                   ??
???????????????????????????????????????
??so       ?MATAZ61                                                     ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function AZ61Lote(nTipo)
	Local nPos       := 0
	Local aArea      := GetArea()
	Local aSB8Area   := SB8->( GetArea() )
	Local lRet       := .T.
	Local lContinua	 := .T.
	Local cVar	     := Upper(ReadVar())
	Local cCont      := &(ReadVar())
	Local cCodProd   := If((nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_COD'    }))>0,aCols[n, nPos],'')
	Local cLocOrig   := If((nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_LOCAL'  }))>0,aCols[n, nPos],'')
	Local cLoteCTL   := If((nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_LOTECTL'}))>0,aCols[n, nPos],'')
	Local cNumLote   := If((nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_NUMLOTE'}))>0,aCols[n, nPos],'')
	Local cCodDest	 := If((nPos := aScan(aHeader, {|x| x[1] == STR0011 }))>0,aCols[n, nPos],'')
	Local cLocDest   := If((nPos := aScan(aHeader, {|x| x[1] == STR0014 }))>0,aCols[n, nPos],'')

	Local nPosDtVldD := aScan(aHeader, {|x| x[1]==STR0046 })
	Local lRastroL   := Rastro(cCodProd, 'L')
	Local lRastroS   := Rastro(cCodProd, 'S')
	Local lRastroD	 := Rastro(cCont)
	Default nTipo	 := 1

	//-- S?Permite Lote ou SubLote
	If cVar # 'M->D3_LOTECTL' .And. cVar # 'M->D3_NUMLOTE'
		lContinua := .F.
	Else
		cLoteCTL := If(cVar=='M->D3_LOTECTL',cCont,cLoteCTL)
		cNumLote := If(cVar=='M->D3_NUMLOTE',cCont,cNumLote)
	EndIf
	If lContinua
		If nTipo == 1
			//-- O campo Lote sempre deve estar preenchido
			If (lRastroL .Or. lRastroS) .And. Empty(cLoteCTL)
				Help(' ',1,'MA260LOTE')
				lContinua	:= .F.
				lRet		:= .F.
			EndIf

			//-- Se o Controle for Lote o campo Sub-Lote nao pode ser preenchido
			If lContinua .And. lRastroL .And. cVar == 'M->D3_NUMLOTE' .And. !Empty(cNumLote)
				&(ReadVar()) := Space(Len(&(ReadVar())))
				lContinua	:= .F.
				lRet		:= .F.
			EndIf

			//-- Se o Sub-Lote nao estiver preenchido, Valida somente o Lote.
			If lContinua .And. lRastroS .And. cVar == 'M->D3_LOTECTL' .And. Empty(cNumLote)
				lRastroL := .T.
				lRastroS := .F.
			EndIf

			If lContinua
				If lRastroL //-- Validacao de Lote
					SB8->(dbSetOrder(3))
					If SB8->(dbSeek(xFilial('SB8') + cCodProd + cLocOrig + cLoteCTL, .F.)) .AND. (dAZ61Data >= SB8->B8_DATA)
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_DTVALID'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_DTVALID
						EndIf
						nPos := aScan(aHeader, {|x| x[1]==STR0046})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_DTVALID
						EndIf
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_POTENCI'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_POTENCI
						EndIf
						If Rastro(cCodProd, 'S')
							nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_NUMLOTE'})
							If nPos > 0
								aCols[n,nPos] := SB8->B8_NUMLOTE
							EndIf
						EndIf
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_LOTECTL'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_LOTECTL
						EndIf
						nSB8Recno     := SB8->(Recno())
					Else
						If		!SB8->(FOUND())
							Help(' ', 1, 'A240LOTERR')
						Endif
						lContinua	:= .F.
						lRet		:= .F.
					EndIf
				ElseIf lRastroS //-- Validacao de Lote e Sub-Lote
					SB8->(dbSetOrder(2))
					If SB8->(dbSeek(xFilial('SB8') + cNumLote + cLoteCTL + cCodProd + cLocOrig, .F.))
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_DTVALID'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_DTVALID
						EndIf
						nPos := aScan(aHeader, {|x| x[1]==STR0046})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_DTVALID
						EndIf
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_POTENCI'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_POTENCI
						EndIf
						If Rastro(cCodProd, 'S')
							nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_NUMLOTE'})
							If nPos > 0
								aCols[n,nPos] := SB8->B8_NUMLOTE
							EndIf
						EndIf
						nPos := aScan(aHeader, {|x| AllTrim(Upper(x[2]))=='D3_LOTECTL'})
						If nPos > 0
							aCols[n,nPos] := SB8->B8_LOTECTL
						EndIf
						nSB8Recno     := SB8->(Recno())
					Else
						Help(' ', 1, 'A240LOTERR')
						lContinua	:= .F.
						lRet		:= .F.
					EndIf
				Else
					&(ReadVar()) := Space(Len(&(ReadVar())))
					lContinua	:= .F.
					lRet		:= .T.
				EndIf
			EndIf
		ElseIf nTipo == 2
			If Rastro(cCodDest) .And. !Empty(cCont)
				dbSelectArea("SB8")
				dbSetOrder(3)
				If dbSeek(xFilial("SB8")+cCodDest+cLocDest+cCont) .And. SB8->B8_DTVALID # aCols[n,nPosDtVldD]
					If !lAutoma261 .And. !Empty(aCols[n,nPosDtVldD])
						Help(" ",1,"A240DTVALI")
					EndIf
					aCols[n,nPosDtVldD] := SB8->B8_DTVALID

				ElseIf Empty(aCols[n,nPosDtVldD])
					aCols[n,nPosDtVldD] := dDataBase
				EndIf
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf

	//-- Retorna Integridade do Sistema
	RestArea( aSB8Area )
	RestArea( aArea )
Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61EstrOk?Autor ?Fernando Joly Siquini ?Data ?01/03/98 ??
???????????????????????????????????????
??escri?o ?Valida se pode ser efetuado o estorno                      ??
???????????????????????????????????????
??intaxe   ?AZ61EstrOk(ExpC1,ExpA1)                                    ??
???????????????????????????????????????
??arametros?ExpC1 - documento									      ??
??         ?ExpA1 - registros relacionados do CQ (SD7)    			  ??
???????????????????????????????????????
??etorno   ?.T. / .F.                                                  ??
???????????????????????????????????????
??so       ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function AZ61EstrOk(cDocumento, aDelSD7)

	Local aArea      := { Alias(), IndexOrd(), Recno() }
	Local aSD3Area   := { 'SD3', SD3->(IndexOrd()), SD3->(Recno()) }
	Local aSD7Area   := { 'SD7', SD7->(IndexOrd()), SD7->(Recno()) }
	Local aSDAArea   := { 'SDA', SDA->(IndexOrd()), SDA->(Recno()) }
	Local lRet       := .T.
	Local nRecCQ     := 0
	Local cSeek      := ''
	Local nX	     := 0
	//??????????????????????????????????
	//?Atribui valores as variaveis de Posicao utilizado no Siga Pyme   ?
	//??????????????????????????????????
	Local nPosEstor := 1		//'Estornado'
	Local nPosCODDes:= 7		//Codigo do Produto Destino
	Local nPosLOCDes:= 10	//Armazem Destino
	Local nPosNumSeq:= 19	//'Sequencia'

	aDelSD7    := If(aDelSD7==NIL,{},aDelSD7)
	cDocumento := If(cDocumento==NIL,'',cDocumento)

	For nX := 1 to Len(aCols)
		If aCols[nX, nPosEstor] == 'S'

			//-- Posiciona SD3
			SD3->(dbSetOrder(2))
			If !SD3->(dbSeek(xFilial('SD3')+cDocumento+aCols[nX,nPosCODDes], .F.))
				Help(' ',1,'A260ESTORN')
				lRet := .F.
				Exit
			EndIf

			//-- Localiza?o - n? estorna Produto Destino j?distribuido
			SDA->(dbSetOrder(1))
			If Localiza(aCols[nX, nPosCODDes]) .And. ;
					SDA->(dbSeek(xFilial('SDA')+aCols[nX,nPosCODDes]+aCols[nX,nPosLOCDes]+aCols[nX,nPosNumSeq],.F.)) .And. ;
					SDA->DA_QTDORI # SDA->DA_SALDO
				Help(' ',1,'SDAJADISTR')
				lRet := .F.
				Exit
			EndIf

			//-- CQ - n? estorna Produto Destino com Movim. no CQ
			SD7->(dbSetorder(3))
			If SD7->(dbSeek(xFilial('SD7') + aCols[nX, nPosCODDes] + aCols[nX, nPosNumSeq], .F.))
				cSeek := xFilial('SD7') + SD7->D7_NUMERO + aCols[nX, nPosCODDes]
				SD7->(dbSetOrder(2))
				If SD7->(dbSeek(cSeek, .F.))
					Do While !SD7->(Eof()) .And. ;
							cSeek == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO
						nRecCQ += If(SD7->D7_TIPO>0.And.Empty(SD7->D7_ESTORNO),1,0)
						If (SD7->D7_TIPO == 0 .Or. (SD7->D7_TIPO > 0 .And. SD7->D7_ESTORNO == 'S')) .And. ;
								aScan(aDelSD7,SD7->(Recno())) == 0
							aAdd(aDelSD7, SD7->(Recno()))
						EndIf
						SD7->(dbSkip())
					EndDo
					If nRecCQ > 0
						Help(' ',1,'AZ61MOVICQ')
						lRet := .F.
						Exit
					EndIf
				EndIf
			EndIf

		EndIf
		//-- Ponto de Entrada para o usuario validar o estorno
		If lMAZ61EST
			lRet := Execblock('MAZ61EST',.f.,.f.,{nX})
			lRet := If(ValType(LRet)#"L",.T.,lRet)
			If !lRet
				Exit
			EndIf
		EndIf
	Next nX

	//-- Retorna Integridade do Sistema
	dbSelectArea(aSD3Area[1]); dbSetOrder(aSD3Area[2]); dbGoto(aSD3Area[3])
	dbSelectArea(aSD7Area[1]); dbSetOrder(aSD7Area[2]); dbGoto(aSD7Area[3])
	dbSelectArea(aSDAArea[1]); dbSetOrder(aSDAArea[2]); dbGoto(aSDAArea[3])
	dbSelectArea(aArea[1]); dbSetOrder(aArea[2]); dbGoto(aArea[3])

Return lRet

/*
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61RetINV?Autor ?Fernando Joly Siquini ?Data ?01/03/98 ??
???????????????????????????????????????
??escri?o ?Retira INVEN do numero do Documento e retorna o novo numero??
???????????????????????????????????????
??intaxe   ?ExpC1 := AZ61RetINV(ExpC2)	                              ??
???????????????????????????????????????
??arametros?ExpC2 - documento "INVEN" ou "SK"						  ??
???????????????????????????????????????
??etorno   ?ExpC1 - novo numero documento                              ??
???????????????????????????????????????
??so       ?MATAZ61                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????*/
Static Function AZ61RetINV(cDoc)
	Local aAreaAnt := GetArea()
	Local aAreaSD3 := SD3->(GetArea())
	Local cFilSD3  := xFilial('SD3')
	Local cRet	   := cDoc
	Local lContinua:= .T.

	If Upper(SubStr(cDoc,1,5)) == 'INVEN'
		dbSelectArea('SD3')
		dbSetOrder(2)
		dbSeek(cFilSD3+'z', .T.)
		If !Eof() .And. D3_FILIAL == cFilSD3 .And. !(Upper(SubStr(D3_DOC,1,5))=='INVEN')
			cDoc 		:= D3_DOC
			cRet 		:= Soma1(cDoc)
			lContinua 	:= .F.
		EndIf
		If lContinua
			dbSeek(cFilSD3+'INVEN')
			dbSkip(-1)
			If !Bof() .And. D3_FILIAL == cFilSD3
				cDoc 		:= D3_DOC
				cRet 		:= Soma1(cDoc)
				lContinua 	:= .F.
			EndIf
		EndIf
		If lContinua
			cRet := StrZero(1,TamSx3("D3_DOC")[1])
		EndIf
	ElseIf Upper(SubStr(cDoc,1,2)) == 'SK'
		dbSelectArea('SD3')
		dbSetOrder(2)
		dbSeek(cFilSD3+'z', .T.)
		If !Eof() .And. D3_FILIAL == cFilSD3 .And. !(Upper(SubStr(D3_DOC,1,2))=='SK')
			cDoc 		:= D3_DOC
			cRet 		:= Soma1(cDoc)
			lContinua 	:= .F.
		EndIf
		If lContinua
			dbSeek(cFilSD3+'SK')
			dbSkip(-1)
			If Upper(SubStr(D3_DOC,1,5)) == 'INVEN'
				dbSeek(cFilSD3+'INVEN')
				dbSkip(-1)
			EndIf
			If !Bof() .And. D3_FILIAL == cFilSD3
				cDoc 		:= D3_DOC
				cRet 		:= Soma1(cDoc)
				lContinua 	:= .F.
			EndIf
		EndIf
		If lContinua
			cRet := StrZero(1,TamSx3("D3_DOC")[1])
		EndIf
	EndIf
	RestArea(aAreaSD3)
	RestArea(aAreaAnt)
Return cRet

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?AZ61DtPot   ?utor?odrigo de A. Sartorio?Data ?19/06/02 ??
???????????????????????????????????????
??escri?o ?Validacao para digitar a validade e potencia do Lote       ??
??         ?corretamente                                               ??
???????????????????????????????????????
??intaxe   ?AZ61DtPot(ExpN1)				                              ??
???????????????????????????????????????
??arametros?ExpN1 - Indica se valida 1 - Data de Validade 2 - Potencia ??
??         ?        3 - Data de Validade de Destino                    ??
???????????????????????????????????????
??etorno   ?.T. / .T.                                                  ??
???????????????????????????????????????
??Uso      ?Mata240                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function AZ61DtPot(nTipo)
	LOCAL nPos
	LOCAL lRet      := .T.
	LOCAL cCod		:= aCols[n,1]
	LOCAL cLocal    := aCols[n,4]
	LOCAL cLoteCtl  := aCols[n,12]	//Lote de Controle
	LOCAL cLote     := aCols[n,13]	//Numero do Lote
	LOCAL dDtValid  := If(nTipo==1,&(ReadVar()),aCols[n,14])
	LOCAL nPosDtvld := 0
	LOCAL nPotencia := If(nTipo==2,&(ReadVar()),aCols[n,15])
	LOCAL cCodDest	:= aCols[n,AsCan(aHeader,{|x| x[1]==STR0011})]
	LOCAL cLoteDest	:= aCols[n,AsCan(aHeader,{|x| x[1]==STR0014})]
	LOCAL cLoteCtlD	:= aCols[n,AsCan(aHeader,{|x| x[1]==STR0044})]
	LOCAL dDtVldDest:= If(nTipo==3,&(ReadVar()),aCols[n,AsCan(aHeader,{|x| x[1]==STR0046})])
	LOCAL aAreaSB8  := SB8->(GetArea())
	LOCAL cAlias    := Alias()

	If nTipo == 3
		If !Rastro(cCodDest)
			Help(" ",1,"NAORASTRO")
			lRet:=.F.
		ElseIf !lAutoma261
			If !Rastro(cCod)
				If !Empty(cLoteCtlD)
					// Verifica se a data de validade pode ser utilizada
					dbSelectArea("SB8")
					dbSetOrder(3)
					If dbSeek(xFilial("SB8")+cCodDest+cLoteDest+cLoteCtlD) .And. SB8->B8_DTVALID # dDtVldDest
						Help(" ",1,"A240DTVALI")
						&(ReadVar()):=SB8->B8_DTVALID
					EndIf
					RestArea(aAreaSB8)
				EndIf
			Else
				If (!Empty(cLoteCtl) .Or. !Empty(cLote)) .And.  dDtVldDest < dDtValid
					ApMsgAlert(STR0069)
					&(ReadVar()):= dDtValid
				EndIf
			EndIf
		EndIf
	Else
		If !Rastro(cCod)
			Help(" ",1,"NAORASTRO")
			lRet:=.F.

		Else
			If !Empty(cLoteCtl) .Or. !Empty(cLote)
				// Verifica se a data de validade pode ser utilizada
				dbSelectArea("SB8")
				dbSetOrder(3)
				dbSeek(xFilial()+cCod+cLocal+cLoteCtl+If(Rastro(cCod,"S"),+cLote,""))
			EndIf
			If nTipo == 1
				If !lAutoma261 .And. !(SB8->(Eof())) .And. (!Empty(cLoteCtl) .Or. !Empty(cLote)) .And. IIF(!Empty(dDtValid),dDtValid # SB8->B8_DTVALID,.T.)
					Help(" ",1,"A240DTVALI")
					&(ReadVar()):=SB8->B8_DTVALID
				EndIf
				If !Empty(&(ReadVar()))
					If &(ReadVar())# dDtVldDest
						nPosDtvld := aScan(aHeader,{|x| Alltrim(x[2])=="D3_DTVALID"})
						aCols[n,nPosDtvld] := &(ReadVar())
					EndIf
				EndIf

			ElseIf nTipo == 2
				If !PotencLote(cCod)
					Help(" ",1,"NAOCPOTENC")
					lRet:=.F.
				EndIf
				If !(SB8->(Eof())) .And. (!Empty(cLoteCtl) .Or. !Empty(cLote)) .And. nPotencia # SB8->B8_POTENCI
					Help(" ",1,"POTENCORI")
					&(ReadVar()):=SB8->B8_POTENCI
				EndIf
			ElseIf nTipo == 3 .And. !lAutoma261
				If  (!Empty(cLoteCtl) .Or. !Empty(cLote)) .And.  dDtVldDest < dDtValid
					ApMsgAlert(STR0069)
					&(ReadVar()):= SB8->B8_DTVALID
				EndIf
			EndIf
			RestArea(aAreaSB8)
		EndIf
	EndIf
	dbSelectArea(cAlias)
Return lRet

/*/
??????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??rograma  ?enuDef   ?Autor ?Fabio Alves Silva     ?Data ?4/10/2006??
???????????????????????????????????????
??escri?o ?Utilizacao de menu Funcional                               ??
??         ?                                                           ??
???????????????????????????????????????
??etorno   ?rray com opcoes da rotina.                                 ??
???????????????????????????????????????
??arametros?arametros do array a Rotina:                               ??
??         ?. Nome a aparecer no cabecalho                             ??
??         ?. Nome da Rotina associada                                 ??
??         ?. Reservado                                                ??
??         ?. Tipo de Transa?o a ser efetuada:                        ??
??         ?  1 - Pesquisa e Posiciona em um Banco de Dados           ??
??         ?   2 - Simplesmente Mostra os Campos                       ??
??         ?   3 - Inclui registros no Bancos de Dados                 ??
??         ?   4 - Altera o registro corrente                          ??
??         ?   5 - Remove o registro corrente do Banco de Dados        ??
??         ?. Nivel de acesso                                          ??
??         ?. Habilita Menu Funcional                                  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
/*/
Static Function MenuDef()
	Private aRotina	:=  {	{STR0002, 'AxPesqui'	, 0 , 1,0,.F.},;	// 'Pesquisar'
		{STR0003, 'U_AZ61Visual'	, 0 , 2,0,nil},;	// 'Visualizar'
		{STR0004, 'U_AZ61Inclui'	, 0 , 3,0,nil},;	// 'Incluir'
		{STR0005, 'U_AZ61Estorn'	, 0 , 6,0,nil},;	// 'Estornar'
		{STR0045, 'A240Legenda'	, 0 , 2,0,.F.},;	// 'Legenda'
		{STR0067, 'CTBC662'	, 0 , 7,0,.F.} }	// "Tracker Cont?il"

	If ExistBlock ("MTAZ61MNU")
		ExecBlock ("MTAZ61MNU",.F.,.F.)
	Endif
Return (aRotina)

/*??????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61PrdGrd?utor  ?odrigo de T. Silva    ?Data ?4/12/2009 ??
???????????????????????????????????????
??escricao ?Interface de Grade de Produtos - Transf. Mod (Mod2)  	   ??
??         ?Substitui a antiga funcao AZ61Produto(cProduto)             ??
???????????????????????????????????????
??arametros?Nenhum                                                      ??
???????????????????????????????????????
??etorno   ?.T. se Valido ou .F. se Invalido                            ??
???????????????????????????????????????
??so       ?etdados do MATAZ61.PRX disparada pelo X3_VALID do D3_COD    ??
???????????????????????????????????????
???????????????????????????????????????
??????????????????????????????????????*/
User Function AZ61PrdGrd()
	Local aArea        := GetArea()
	Local cNewItem     := ""
	Local cPrdOrig     := ""
	Local cCpoName     := StrTran(ReadVar(),"M->","")
	Local cSaveReadVar := __READVAR
	Local lGrade       := MaGrade()
	Local lReferencia  := .F.
	Local lAadd        := .F.
	Local lQtdZero     := .F.
	Local lRet         := .T.
	Local nSaveN
	Local nNewItem
	Local nPosProd
	Local nPLocal
	Local nPosQuant
	Local nPosCusto1
	Local nPosQtSegum
	Local nLinX        := 0
	Local nColY        := 0
	Local nY           := 0
	Local nOpca        := 0
	Local oDlg

	//???????????????????????????????????????????????????????????????
	//?erifica se a grade esta ativa e se o produto digitado e uma referencia e Monta o AcolsGrade e o AheadGrade para este item ?
	//???????????????????????????????????????????????????????????????
	cProdRef    := &(ReadVar())
	lReferencia := MatGrdPrrf(@cProdRef)
	If lReferencia .And. lGrade .And. !Empty(&(ReadVar()))
		nSaveN       	:= N
		nNewItem     	:= Len(aCols)
		nPosProd     	:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_COD"})
		nPLocal			:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_LOCAL"})
		nPosQuant    	:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_QUANT"})
		nPosCusto1		:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_CUSTO1"})
		nPosQtSegum  	:= aScan(aHeader,{|x| AllTrim(x[2])=="D3_QTSEGUM"})
		PRIVATE oGrade  := MsMatGrade():New('oGrade', , 'D3_QUANT', , 'AZ61VldGrd()', {{VK_F4, { || ShowF4() } }},;
			{{"D3_QUANT"    ,.T., {{"D3_QTSEGUM", {|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) }}} },;
			{"D3_QTSEGUM"  ,NIL, {{"D3_QUANT"  , {|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) }}} },;
			{"D3_LOCAL"    ,NIL, NIL},;
			{"D3_CUSTO1"   ,NIL, NIL};
			})
		//????????????????????????????????
		//?So aceita a entrada de dados via interface de grade se o usr ?
		//?estiver posicionado na ultima linha da MsGetdados (NewLine). ?
		//????????????????????????????????
		If N >= Len(aCols) .And. Empty(aCols[Len(aCols)][nPosProd])
			oGrade:MontaGrade(1,cProdRef,.T.,,lReferencia,.T.)
			oGrade:nPosLinO     := 1
			oGrade:cProdRef	    := cProdRef
			oGrade:lShowMsgDiff := .F. // Desliga apresentacao do "A410QTDDIF"

			nNewItem := Len(aCols)
			lAadd    := .F.

			DEFINE MSDIALOG oDlg TITLE STR0060 OF oMainWnd PIXEL FROM 000,000 TO 220,520  //"Interface para Grade de Produtos"

			@ 035,010 BUTTON STR0020 SIZE 70,15 FONT oDlg:oFont ACTION ;
				{|| __READVAR:='M->D3_QUANT'  ,M->D3_QUANT   := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Quantidade"
			@ 055,010 BUTTON STR0021 SIZE 70,15 FONT oDlg:oFont ACTION ;
				{|| __READVAR:='M->D3_QTSEGUM',M->D3_QTSEGUM := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Segunda Und Medida"

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End(), nOpca:=1},{||oDlg:End(), nOpca:=0}) CENTERED

			//??????????????????????????????????????????????????
			//?Somente realiza a carga do item para o aCols se pelo menos uma celula do D3_QUANT contiver valor.?
			//??????????????????????????????????????????????????
			If nOpca == 1
				If If(lQtdZero,oGrade:SomaGrade("D3_QTSEGUM",oGrade:nPosLinO,oGrade:nQtdInformada) <> 0,oGrade:SomaGrade("D3_QUANT",oGrade:nPosLinO,oGrade:nQtdInformada) > 0)
					For nLinX := 1 To Len(oGrade:aColsGrade[1])
						For nColY := 2 To Len(oGrade:aHeadGrade[1])
							If oGrade:aColsFieldByName("D3_QUANT",1,nLinX,nColY)  > 0
								//????????????????????????????????
								//?Faz a montagem de uma nova linha em branco no aCols para     ?
								//?adicionar novos itens vindos das celulas da Grade.           ?
								//????????????????????????????????
								If lAadd
									aadd(aCols,Array(Len(aHeader)+1))
									N := nNewItem
									nNewItem := Len(aCols)
									cNewItem := StrZero(nNewItem,Len(SD1->D1_ITEM))
									For nY := 1 to Len(aHeader)
										If Trim(aHeader[nY][2]) == "D3_COD"
											aCols[nNewItem][nY] := PadR(oGrade:GetNameProd(cProdRef,nLinX,nColY),Len(SD1->D1_COD))
										ElseIf IsHeadRec(aHeader[nY][2])
											aCols[nNewItem][nY] := 0
										ElseIf IsHeadAlias(aHeader[nY][2])
											aCols[nNewItem][nY] := "SD3"
										Else
											aCols[nNewItem][nY] := CriaVar(aHeader[nY][2])
										EndIf
										aCols[nNewItem][Len(aHeader)+1] := .F.
									Next nY
								EndIf
								//??????????????????????????????????????
								//?fetua a carga dos itens digitados no grid para o aCols                  ?
								//?xecuta as validacoes necessarias para se carregar corretamente os dados ?
								//??????????????????????????????????????
								aCols[nNewItem][nPosProd]:= PadR(oGrade:GetNameProd(cProdRef,nLinX,nColY),Len(SD1->D1_COD))
								DbSelectArea("SB1")
								If dbSeek(xFilial()+alltrim(aCols[nNewItem][nPosProd]),.T.)
									M->D3_COD := aCols[nNewItem][nPosProd]
									aCols[nNewItem][nPosQuant]:= oGrade:aColsFieldByName("D3_QUANT",1,nLinX,nColY)
									M->D3_QUANT   := oGrade:aColsFieldByName("D3_QUANT",1,nLinX,nColY)
									aCols[nNewItem][nPosQtSegum]:= oGrade:aColsFieldByName("D3_QTSEGUM",1,nLinX,nColY)
									M->D3_QTSEGUM := oGrade:aColsFieldByName("D3_QTSEGUM",1,nLinX,nColY)
									AQtdGrade()  //-- Deve ser executada somente neste momento pois o objeto oGrade esta ativo
									aCols[nNewItem,2] := SB1->B1_DESC
									aCols[nNewItem,3] := SB1->B1_UM
									aCols[nNewItem,4] := SB1->B1_LOCPAD
									aCols[nNewItem,6] := aCols[nNewItem,1]
									aCols[nNewItem,7] := aCols[nNewItem,2]
									aCols[nNewItem,8] := aCols[nNewItem,3]
									If !lAadd
										cPrdOrig := aCols[nNewItem][nPosProd]
										lAadd 	 := .T.
									EndIf
								EndIf
							EndIf
						Next nColY
					Next nLinX
				Else
					lRet := .F.
				EndIf
			EndIf
			//??????????????????????????????????
			//?estaura os valores originais do N da GetDados, e da Public      ?
			//?_READVAR que fora manipulada pela interface de grade.           ?
			//??????????????????????????????????
			N         := nSaveN
			__READVAR := cSaveReadVar
			M->D3_COD := cPrdOrig
		Else
			//??????????????????????????????????
			//?ara incluir um produto com referencia de grade e necessario estar?
			//?m uma nova linha do movimento interno.                           ?
			//??????????????????????????????????
			Help(" ",1,"A241PRDGRD")
			lRet := .F.
		EndIf
	Else
		//????????????????????????????????????
		//?Se o Produto nao for um produto de grade executa a validacao no SB1 ?
		//?e inicializa os campos na getdados.                                 ?
		//????????????????????????????????????
		dbSelectArea("SB1")
		dbSetOrder(1)
		lRet := ExistCpo("SB1")
	EndIf
	RestArea(aArea)
Return(lRet)

/*??????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un?o    ?Z61VldGrd?utor  ?odrigo de T. Silva	?Data ?4/12/2009 ??
???????????????????????????????????????
??escricao ?Validacao dos itens do Grid na grade de produtos            ??
???????????????????????????????????????
??arametros?Nenhum                                                      ??
???????????????????????????????????????
??etorno   ?.T. se Valido e .F. se Invalido                             ??
???????????????????????????????????????
??so       ?bjeto de Grade do MATAZ61                                   ??
???????????????????????????????????????
???????????????????????????????????????
??????????????????????????????????????*/
Static Function AZ61VldGrd()
	Local lValido := .F.

	//????????????????????????????????????
	//?Se Houver necessidade de novas validacoes na entrada de dados nas   ?
	//?celulas do Grid elas deverao ser inseridas nessa funcao.            ?
	//????????????????????????????????????
	If Positivo()
		lValido := .T.
	EndIf

Return lValido

/*
????????????????????????????????????????
????????????????????????????????????????
????????????????????????????????????????
??Função   ?IntegDef ?Autor ?Flavio San Miguel    ?Data ? 17/12/13   ??
????????????????????????????????????????
??Descricao ?Funcao de tratamento para a mensagem unica de transferencia  ??
??          ?de Armazem Modelo II (TRANSFERWAREHOUSELOT)                  ??
????????????????????????????????????????
??Uso       ?MATAZ61                                                      ??
????????????????????????????????????????
????????????????????????????????????????
????????????????????????????????????????
*/
Static Function IntegDef(cXML,nTypeTrans,cTypeMessage)
Return MATIZ61(cXml,nTypeTrans,cTypeMessage)

/*----------------------------------------------------
 Suavizar a nova verifica?o de integra?o com o WMS
------------------------------------------------------*/
Static Function aZ61IntWMS(cProduto)
	Default cProduto := ""
	If __lIntWMS
		Return IntWMS(cProduto)
	Else
		Return IntDL(cProduto)
	EndIf
Return

/*
????????????????????????????????????????
????????????????????????????????????????
????????????????????????????????????????
??Função  ?aZ61VldDt?Autor ?Lucas Crevilari      ?Data ? 13/07/17   ??
????????????????????????????????????????
??Descricao ?Funcao para valida?o da data de fechamento                  ??
????????????????????????????????????????
??Uso       ?MATAZ61                                                      ??
????????????????????????????????????????
????????????????????????????????????????
????????????????????????????????????????
*/

Static Function MaZ61VldDt( dDataFec, dAZ61Data)
	Local lRet	:= .T.

	Default dDataFec  := dDataBase
	Default dAZ61Data := dDataBase

	If (dDataFec >= dAZ61Data)
		Help (' ', 1, 'FECHTO')
		lRet := .F.
	Endif

	If lRet .And. !VldUser('D3_EMISSAO')
		lRet := .F.
	Endif

Return lRet

/*/{Protheus.doc} zArrToTxt
Função que exporta um array para Texto
@author Atilio
@since 21/08/2015
@version 1.0
    @param aAuxiliar, Array, Array com os dados que serão impressos
    @param lQuebr, Lógico, Define se a cada posição do array, quebra o texto
    @param cArqGera, Caracter, Arquivo a ser gerado com o conteúdo do array
    @example
    u_zArrToTxt(aArray, .T., "E:\teste_aux.txt")
    @return cTextoAux, Variável que é retornada (contendo o array em formato txt)
/*/

User Function zArrToTxt(aAuxiliar, lQuebr, cArqGera)
	Local cTextoAux := ""
	Local nLimite       := 63000 //Forçando o tamanho máximo a 63.000 bytes
	Local nLinha        := 0
	Local nNivel        := 0
	Default aAuxiliar   := {}
	Default lQuebr  := .T.
	Default cArqGera    := ""

	//Se tiver linhas para serem processadas
	If Len(aAuxiliar) > 0
		//Percorrendo o Array
		For nLinha := 1 To Len(aAuxiliar)
			fImprArray(aAuxiliar[nLinha], @cTextoAux, nNivel, lQuebr, nLimite, nLinha)
		Next

		//Se não tiver em branco, gera o arquivo
		If !Empty(cArqGera)
			MemoWrite(cArqGera, cTextoAux)
		EndIf
	EndIf
Return cTextoAux

/*---------------------------------------------------------------------*
 | Func:  fImprArray                                                   |
 | Autor: Daniel Atilio                                                |
 | Data:  21/08/2015                                                   |
 | Desc:  Função que gera a linha do arquivo (recursivamente)          |
*---------------------------------------------------------------------*/

Static Function fImprArray(xDadAtu, cTextoAux, nNivel, lQuebr, nLimite, nPosicao)
	Local cEspac := Space(nNivel)
	Local nColuna := 0

	//Finaliza o laço
	If Len(cTextoAux) >= nLimite
		Return
	EndIf

	//Se o tipo for numérico
	If ValType(xDadAtu) == "N"
		cTextoAux += cEspac+"["+StrZero(nPosicao, 4)+"][Type:N] "+cValToChar(xDadAtu) + Iif(lQuebr, STR_PULA, '')

		//Se for Data
	ElseIf ValType(xDadAtu) == "D"
		cTextoAux += cEspac+"["+StrZero(nPosicao, 4)+"][Type:D] "+dToC(xDadAtu) + Iif(lQuebr, STR_PULA, '')

		//Se for Array
	ElseIf ValType(xDadAtu) == "A"
		cTextoAux += cEspac+"["+StrZero(nPosicao, 4)+"][Type:A]" + Iif(lQuebr, STR_PULA, '')
		nNivel++
		//Percorrendo o Array
		For nColuna := 1 To Len(xDadAtu)
			fImprArray(xDadAtu[nColuna], @cTextoAux, nNivel, lQuebr, nLimite, nColuna)
		Next

		//Se for Lógico
	ElseIf ValType(xDadAtu) == "L"
		cTextoAux += cEspac+"["+StrZero(nPosicao, 4)+"][Type:L] "+cValToChar(xDadAtu) + Iif(lQuebr, STR_PULA, '')

		//Senão, apenas mostra o conteúdo (Memo, Char, etc)
	Else
		cTextoAux += cEspac+"["+StrZero(nPosicao, 4)+"][Type:"+ValType(xDadAtu)+"] "+Alltrim(xDadAtu) + Iif(lQuebr, STR_PULA, '')
	EndIf
Return


User Function AZ61Doc(oGet,aCols,cDocumento,nOpcX,oDlg)
	Local lContinua := .T.
	Local _cAlias   := GetArea()
	cSeek := xFilial('SD4')+left(cDocumento,8)
	dbSelectArea("SD4")
	dbSetorder(2)
	If !SD4->(dbSeek(cSeek,.F.))
		FWAlertError("Ordem de Produção não ncontrada","Atenção")
		lContinua := .F.
	EndIf
	RestArea(_cAlias)
Return lContinua

User Function Preenche(oGet,aCols,cDocumento,nOpcX,oDlg)
	Local lContinua := .T.
	Local nPosCODOri  := 1
	Local nPosDOri	:= 2	//Descricao do Produto Origem
	Local nPosUMOri	:= 3	//Unidade de Medida Origem
	Local nPosLOCOri 	:= 4	//Armazem Origem
	Local nPosLcZOri 	:= 5	//Localizacao Origem
	Local nPosCODDes 	:= 6 	//Codigo do Produto Destino
	Local nPosDDes	:= 7	//Descricao do Produto Destino
	Local nPosUMDes	:= 8	//Unidade de Medida Destino
	Local nPosLOCDes	:= 9	//Armazem Destino
	Local nPosLcZDes	:= 10	//Localizacao Destino
	Local nPosNSer	:= 11	//Numero de Serie
	Local nPosLoTCTL 	:= 12	//Lote de Controle
	Local nPosNLOTE	:= 13	//Numero do Lote
	Local nPosDTVAL	:= 14	//Data Valida
	Local nPosPotenc := 15	//Potencia do Lote
	Local nPosQUANT	:= 16	//Quantidade
	Local nPosQTSEG	:= 17	//Quantidade na 2a. Unidade de Medida
	Local nPosEstor	:= 18	//Estornado
	Local nPosNumSeq	:= 19	//Sequencia
	Local nPosLotDes	:= 20	//Lote Destino
	Local nPosDtVldD	:= 21	//Data Valida de Destino
	Local nPosPerImp	:= 0
	Local nPosCAT83O	:= 0   //Cod.CAT 83 Prod.Origem
	Local nPosCAT83D	:= 0   //Cod.CAT 83 Prod.Destino
	Local lMAZ61In	:= (ExistBlock('MAZ61IN'))	//-- Atribui valores nos campos de usuario
	Local nPosServic := 22	//Serviço
	Local nPosMemo   := 25	//Campos Memo

	cSeek := xFilial('SD4')+left(cDocumento,8)
	nCont  := 0
	nConta := 1
	dbSelectArea("SD4")
	nRegSD4 := recno()
	nTotRegs := 0
	While lContinua .And. !SD4->(Eof()) .And. SD4->D4_FILIAL+left(SD4->D4_OP,8) == cSeek
		If SD4->D4_QUANT > 0
			cNumSeq := SD4->D4_SEQ
			nTotRegs += 1
			nCont ++
		Else
			SD4->(dbSkip())
			Loop
		EndIf

		If nCont > 1
			aAdd(aCols, Array(Len(aHeader)+1))
		Endif

		//-- Posiciona o Arquivo de Produtos (SB1)
		If !SB1->(dbSeek(xFilial('SB1')+SD4->D4_COD,.F.))
			Help(' ', 1, 'REGNOIS')
			lContinua := .F.
			Exit
		EndIf
		aCols[Len(aCols),nPosCODOri]   	:= SD4->D4_COD
		aCols[Len(aCols),nPosDOri]     	:= SB1->B1_DESC
		aCols[Len(aCols),nPosUMOri]    	:= SB1->B1_UM
		aCols[Len(aCols),nPosLOCOri]   	:= SD4->D4_LOCAL
		aCols[Len(aCols),nPosLcZOri]   	:= ""
		aCols[Len(aCols),nPosCODDes]   	:= SD4->D4_COD
		aCols[Len(aCols),nPosDDes]     	:= SB1->B1_DESC
		aCols[Len(aCols),nPosUMDes]    	:= SB1->B1_UM
		If SD4->D4_LOCAL == "01"
			aCols[Len(aCols),nPosLOCDes]   	:= "11""
			ElseI SD4->D4_LOCAL == "11"
			aCols[Len(aCols),nPosLOCDes]   	:= "01""
		Else
			aCols[Len(aCols),nPosLOCDes]   	:= "11""
		Endif
		aCols[Len(aCols),nPosLcZDes]   	:= ""
		aCols[Len(aCols),nPosNSer]  	:= ""
		aCols[Len(aCols),nPosLoTCTL]	:= SD4->D4_LOTECTL
		aCols[Len(aCols),nPosNLOTE] 	:= SD4->D4_NUMLOTE
		aCols[Len(aCols),nPosDTVAL] 	:= SD4->D4_DTVALID
		aCols[Len(aCols),nPosPotenc]	:= SD4->D4_POTENCI
		aCols[Len(aCols),nPosQUANT]    	:= SD4->D4_QUANT
		aCols[Len(aCols),nPosQTSEG]    	:= SD4->D4_QTSEGUM
		aCols[Len(aCols),nPosEstor]    	:= ""
		aCols[Len(aCols),nPosNumSeq]   	:= SD4->D4_SEQ
		aCols[Len(aCols),nPosLotDes]	:= SD4->D4_LOTECTL
		aCols[Len(aCols),nPosDtVldD] 	:= SD4->D4_DTVALID
		aCols[Len(aCols),nPosServic]   	:= ""
		aCols[Len(aCols)][Len(aHeader)-1] := "SD3"
		aCols[Len(aCols)][Len(aHeader)]	  := SD4->(RecNo())
		aCols[Len(aCols),nPosMemo]    	:= .F.

		If !lContinua
			Exit
		EndIf

		//-- ExecBlock para atribuir valores nos campos de usuario
		If lMAZ61In
			ExecBlock('MAZ61IN',.F.,.F.)
		EndIf
		nCont ++
		dbSkip()
	EndDo
	oGet:oBrowse:Refresh()
	oGet:Refresh()
Return

User Function MAZ61Saldo(cProduto,cLocal,nQuant)
	__cAlias := GetArea()
	nTotlocal := nQuant
	If nQuant <= 0
		RestArea(__cAlias)
		Return ntotLocal
	Endif

	dbSelectArea("SB2")
	dbSetOrder(1)
	msSeek(xFilial()+cProduto+cLocal)
	//nTotLocal := SaldoSB2()
	nTotLocal := SB2->B2_QATU
	If nTotLocal < nQuant
		FWAlertError("Saldo em estoque: "+str(nTotLocal,10,2),"Atenção")
		nTotLocal := 0
	Else
		nTotLocal := nQuant
	Endif
	RestArea(__cAlias)
Return nTotLocal

User Function MAZ61D3

	Local ___cAlias  := GetArea()
	Local nLocDes := 9
	Local nPosReg := 24

	//Alert("MA261D3")
	dbSelectArea("sD4")
	dbGoto(nPosReg)
	RecLock('SD4',.F.)
	SD4->D4_LOCAL := aCols[n,nLocDes]
	MsUnlock()
	RestArea(___cAlias)

Return
User Function MAZ61LIN
	Local nLinha := PARAMIXB[1]// numero da linha do aCols
	Local nPosCodOri := 1
	Local nPosLocOri := 4
	Local nPosQuant  := 16
	Local lRet := .T.

	cCodigo := aCols[nLinha,nPosCodOri]
	cLocal  := aCols[nLinha,nPosLocOri]
	nQuant  := aCols[nLinha,nPosQuant]

	If nQuant <= 0
		Return lRet
	Endif
	dbSelectArea("SB2")
	dbSetOrder(1)
	msSeek(xFilial()+cCodigo+cLocal)
	//nTotLocal := SaldoSB2()
	nTotLocal := SB2->B2_QATU
	If nTotLocal < nQuant
		FWAlertError("Saldo em estoque: "+str(nTotLocal,10,2),"Produto "+cCodigo)
		nTotLocal := 0
		lRet := .F.
	Else
		nTotLocal := nQuant
	Endif
Return lRet

